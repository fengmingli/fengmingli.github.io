<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>神奇的高性能无锁队列JCTools | LiFengMing</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/lfm_title.png">
    <meta name="description" content="">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.74078a8e.css" as="style"><link rel="preload" href="/assets/js/app.89da10ab.js" as="script"><link rel="preload" href="/assets/js/2.8e04b068.js" as="script"><link rel="preload" href="/assets/js/19.d6a4cc61.js" as="script"><link rel="prefetch" href="/assets/js/10.5e7fe968.js"><link rel="prefetch" href="/assets/js/11.01dd294c.js"><link rel="prefetch" href="/assets/js/12.07fce99c.js"><link rel="prefetch" href="/assets/js/13.4a07fd33.js"><link rel="prefetch" href="/assets/js/14.91957f95.js"><link rel="prefetch" href="/assets/js/15.73a52305.js"><link rel="prefetch" href="/assets/js/16.af7017eb.js"><link rel="prefetch" href="/assets/js/17.e9c76188.js"><link rel="prefetch" href="/assets/js/18.255d6ad0.js"><link rel="prefetch" href="/assets/js/20.ab12a26a.js"><link rel="prefetch" href="/assets/js/21.efe91574.js"><link rel="prefetch" href="/assets/js/22.c87353e8.js"><link rel="prefetch" href="/assets/js/23.0d1d44af.js"><link rel="prefetch" href="/assets/js/24.9110c168.js"><link rel="prefetch" href="/assets/js/25.191ad91e.js"><link rel="prefetch" href="/assets/js/26.b48ff2fb.js"><link rel="prefetch" href="/assets/js/27.59bb592a.js"><link rel="prefetch" href="/assets/js/28.b52dd30a.js"><link rel="prefetch" href="/assets/js/29.b0f1a200.js"><link rel="prefetch" href="/assets/js/3.a2e7efd6.js"><link rel="prefetch" href="/assets/js/30.8d263b10.js"><link rel="prefetch" href="/assets/js/31.3de9e18a.js"><link rel="prefetch" href="/assets/js/32.7ab46bd3.js"><link rel="prefetch" href="/assets/js/33.414d9789.js"><link rel="prefetch" href="/assets/js/34.ee28dec8.js"><link rel="prefetch" href="/assets/js/35.9f5b9457.js"><link rel="prefetch" href="/assets/js/36.57abbba3.js"><link rel="prefetch" href="/assets/js/37.5d0bdfc6.js"><link rel="prefetch" href="/assets/js/38.2b079d88.js"><link rel="prefetch" href="/assets/js/39.5d0ce58a.js"><link rel="prefetch" href="/assets/js/4.d5193ec3.js"><link rel="prefetch" href="/assets/js/40.cc188046.js"><link rel="prefetch" href="/assets/js/41.1ccc15c8.js"><link rel="prefetch" href="/assets/js/42.b7f0d39a.js"><link rel="prefetch" href="/assets/js/43.aa694136.js"><link rel="prefetch" href="/assets/js/44.48cc0a37.js"><link rel="prefetch" href="/assets/js/45.b6167c45.js"><link rel="prefetch" href="/assets/js/46.5566fae8.js"><link rel="prefetch" href="/assets/js/47.785c40dd.js"><link rel="prefetch" href="/assets/js/48.4b0c2331.js"><link rel="prefetch" href="/assets/js/49.69deb0a5.js"><link rel="prefetch" href="/assets/js/5.79cbe7c1.js"><link rel="prefetch" href="/assets/js/50.83e3541f.js"><link rel="prefetch" href="/assets/js/51.022581a3.js"><link rel="prefetch" href="/assets/js/52.d4987378.js"><link rel="prefetch" href="/assets/js/53.f6e68690.js"><link rel="prefetch" href="/assets/js/54.e5908b26.js"><link rel="prefetch" href="/assets/js/55.fd21586d.js"><link rel="prefetch" href="/assets/js/56.8d5d4486.js"><link rel="prefetch" href="/assets/js/57.4614524d.js"><link rel="prefetch" href="/assets/js/58.14cde33e.js"><link rel="prefetch" href="/assets/js/59.8d1e5dd0.js"><link rel="prefetch" href="/assets/js/6.2bd77ea1.js"><link rel="prefetch" href="/assets/js/60.e6509ca1.js"><link rel="prefetch" href="/assets/js/61.32961546.js"><link rel="prefetch" href="/assets/js/62.f355dd9a.js"><link rel="prefetch" href="/assets/js/63.43230ff3.js"><link rel="prefetch" href="/assets/js/64.5af8007f.js"><link rel="prefetch" href="/assets/js/65.fe7e36f0.js"><link rel="prefetch" href="/assets/js/66.5202ab0d.js"><link rel="prefetch" href="/assets/js/67.dc162127.js"><link rel="prefetch" href="/assets/js/7.2bde0a66.js"><link rel="prefetch" href="/assets/js/8.27ed2920.js"><link rel="prefetch" href="/assets/js/9.9787f48a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.74078a8e.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/lfm_title.png" alt="LiFengMing" class="logo"> <span class="site-name can-hide">LiFengMing</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/cloudNative/" class="nav-link">云原生</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">中间件</a></div><div class="nav-item"><a href="/technology/" class="nav-link">工具导航</a></div><div class="nav-item"><a href="/resourceNavigation/" class="nav-link">资源导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引导航" class="dropdown-title"><a href="/categories/" class="link-title">索引导航</a> <span class="title" style="display:none;">索引导航</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/pages/c92c72/" class="nav-link">关于作者</a></div> <a href="https://github.com/fengmingli" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg"> <div class="blogger-info"><h3>LiFengMing</h3> <span>IT届李哥</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/cloudNative/" class="nav-link">云原生</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">中间件</a></div><div class="nav-item"><a href="/technology/" class="nav-link">工具导航</a></div><div class="nav-item"><a href="/resourceNavigation/" class="nav-link">资源导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引导航" class="dropdown-title"><a href="/categories/" class="link-title">索引导航</a> <span class="title" style="display:none;">索引导航</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/pages/c92c72/" class="nav-link">关于作者</a></div> <a href="https://github.com/fengmingli" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>编程语言</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Go</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/de07b7/" class="sidebar-link">高性能无锁队列简介</a></li><li><a href="/pages/1fb748/" class="sidebar-link">漫谈内存伪共享</a></li><li><a href="/pages/45b009/" class="sidebar-link">漫谈JVM内存屏障</a></li><li><a href="/pages/7cb530/" class="sidebar-link">漫谈JDK原生并发队列</a></li><li><a href="/pages/d4307f/" class="sidebar-link">神奇的高性能无锁队列Disruptor</a></li><li><a href="/pages/c89bba/" aria-current="page" class="active sidebar-link">神奇的高性能无锁队列JCTools</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/c89bba/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/c89bba/#什么是jctools" class="sidebar-link">什么是JCTools</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/c89bba/#非阻塞-map" class="sidebar-link">非阻塞 Map</a></li><li class="sidebar-sub-header level3"><a href="/pages/c89bba/#非阻塞-queue" class="sidebar-link">非阻塞 Queue</a></li><li class="sidebar-sub-header level3"><a href="/pages/c89bba/#基于实现数据结构分类" class="sidebar-link">基于实现数据结构分类</a></li><li class="sidebar-sub-header level3"><a href="/pages/c89bba/#源码解析" class="sidebar-link">源码解析</a></li><li class="sidebar-sub-header level4"><a href="/pages/c89bba/#入队offer" class="sidebar-link">入队offer()</a></li><li class="sidebar-sub-header level4"><a href="/pages/c89bba/#出队poll" class="sidebar-link">出队Poll</a></li><li class="sidebar-sub-header level3"><a href="/pages/c89bba/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level3"><a href="/pages/c89bba/#说明" class="sidebar-link">说明</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/c89bba/#参考文档" class="sidebar-link">参考文档</a></li></ul></li><li><a href="/pages/405ff8/" class="sidebar-link">Linux内核之kfifo</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span> 问题排查手册</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>容器编排技术</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/cloudNative/#云原生" data-v-06225672>云原生</a></li><li data-v-06225672><a href="/cloudNative/#编程语言" data-v-06225672>编程语言</a></li><li data-v-06225672><a href="/cloudNative/#Java" data-v-06225672>Java</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/fengmingli" target="_blank" title="作者" class="beLink" data-v-06225672>LiFengMing</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2020-09-20</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">神奇的高性能无锁队列JCTools<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>最近在看Netty源码的时候，关注到了JCTools。JCTools是什么？是一个高性能的无锁并发工具包。早在96年就有论文提出了无锁队列的概念，再到后来 Disruptor，高性能已得到生产的验证。此处介绍的 Jctools 中的高性能队列，其性能丝毫不输于 Disruptor。那Disruptor与JCTools都是高性能队列的处理有什么区别了？</p> <h2 id="什么是jctools"><a href="#什么是jctools" class="header-anchor">#</a> 什么是JCTools</h2> <p>JCTools (Java Concurrency Tools) 提供了一系列非阻塞并发数据结构（标准 Java 中缺失的），当存在线程争抢的时候，非阻塞并发数据结构比阻塞并发数据结构能提供更好的性能。</p> <p>CTools 是适用于 JVM 并发开发的工具，主要提供了一些 JDK 确实的并发数据结构，例如非阻塞 Map、非阻塞 Queue 等。其中非阻塞队列可以分为四种类型，可以根据不同的场景选择使用。</p> <p>JCTools 是一个开源工具包，在 Apache License 2.0 下发布，并在 Netty、Rxjava 等诸多框架中被广泛使用。</p> <h3 id="非阻塞-map"><a href="#非阻塞-map" class="header-anchor">#</a> 非阻塞 Map</h3> <ul><li>ConcurrentAutoTable
<ul><li>后面几个map/set结构的基础</li></ul></li> <li>NonBlockingHashMap :
<ul><li>是对 ConcurrentHashMap 的增强，对多 CPU 的支持以及高并发更新提供更好的性能。</li></ul></li> <li>NonBlockingHashMapLong
<ul><li>是 key 为 Long 型的 NonBlockingHashMap。</li></ul></li> <li>NonBlockingHashSet
<ul><li>是对 NonBlockingHashMap 的简单包装以支持 set 的接口。</li></ul></li> <li>NonBlockingIdentityHashMap
<ul><li>是从 NonBlockingHashMap 改造来的，使用 System.identityHashCode() 来计算哈希。</li></ul></li> <li>NonBlockingSetInt
<ul><li>是一个使用 CAS 的简单的 bit-vector。</li></ul></li></ul> <h3 id="非阻塞-queue"><a href="#非阻塞-queue" class="header-anchor">#</a> 非阻塞 Queue</h3> <p>JCTools 提供的非阻塞队列分为 四种类型，可以根据不同的应用场景选择使用：</p> <ul><li>Spsc：单生产者单消费者（有界和无界）</li> <li>Mpsc：多生产者单消费者（有界和无界）</li> <li>Spmc：单生产者多消费者（有界）</li> <li>Mpmc：多生产者多消费者（有界）</li></ul> <p>“生产者”和“消费者”是指“生产线程”和“消费线程”。</p> <h3 id="基于实现数据结构分类"><a href="#基于实现数据结构分类" class="header-anchor">#</a> 基于实现数据结构分类</h3> <ul><li>基于数组的队列：
<ul><li>MpscArrayQueue</li> <li>MpmcArrayQueue</li> <li>SpscArrayQueue</li> <li>SpmcArrayQueue</li></ul></li> <li>基于链表的队列：
<ul><li>MpscLinkedQueue</li> <li>SpscLinkedQueue</li></ul></li> <li>基于<strong>LinkedArray</strong>的队列
<ul><li>SpscChunkedArrayQueue</li> <li>SpscGrowableArrayQueue</li> <li>SpscUnboundedArrayQueue</li> <li>MpscGrowableArrayQueue</li> <li>MpscChunkedArrayQueue</li> <li><strong>MpscUnboundedArrayQueue（Netty中使用）</strong></li></ul></li> <li>XaddQueue：
<ul><li>MpscUnboundedXaddArrayQueue</li> <li>MpmcUnboundedXaddArrayQueue</li></ul></li> <li>其它类型队列：
<ul><li>MpscCompoundQueue</li></ul></li></ul> <h3 id="源码解析"><a href="#源码解析" class="header-anchor">#</a> 源码解析</h3> <p>首先我们先从简单的 MpscArrayQueue 队列的源码开始分析：</p> <img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/MpscArrayQueue.png" width="100%" height="550"> <h4 id="入队offer"><a href="#入队offer" class="header-anchor">#</a> 入队offer()</h4> <p>跟进源码之前，首先回顾下 MpscArrayQueue 的重要属性</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// ConcurrentCircularArrayQueue</span>
   <span class="token comment">/**
    * Q：这个值有什么作用？
    * A：数组长度对应的掩码 - 方便用&amp;运算代替较慢的%运算 子类需要继续缓存行填充，以避免mask 和 buffer 产生伪共享
    * eg.        capacity=16     0000 0000 0001 0000
    *      mask: capacity-1=15   0000 0000 0000 1111
    *  h &amp; (length-1) = h % length
    */</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">long</span> mask<span class="token punctuation">;</span> 

<span class="token comment">// 真正存放队列数据的数组</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">;</span> 


<span class="token comment">// MpmcArrayQueueProducerIndexField</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> producerIndex<span class="token punctuation">;</span> <span class="token comment">// 生产者的索引</span>

<span class="token comment">// MpscArrayQueueProducerLimitField</span>
    <span class="token comment">/**
     * 在重新读取消费者索引之前，第一个不可用的生产者索引。
     * &lt;p&gt;
     * Q: 这个值有什么用，直接读取consumerIndex计算不行吗?
     * A: {@code consumerIndex}是一个变化较为频繁的值，因此它所在的缓存行极易失效，从而影响读性能。
     * 我们拷贝一个副本（并在副本无效的时候更新），这样可以减少生产者与消费者之间产生的伪共享，从而提高读效率.
     * &lt;p&gt;
     * Q: 该值为什么进行缓存行填充，为什么与producerIndex分离？
     * A: 因为是多生产模式，因此producerIndex上将产生高度竞争，因此其所在的缓存行极易失效，
     * 将该值与producerIndex分开，我们期望该值大部分时间位于用于共享（且很少失效）的缓存行中。
     * PS: 该值的更新频率远低于producerIndex。
     */</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> producerLimit<span class="token punctuation">;</span> 

<span class="token comment">// MpscArrayQueueConsumerIndexField</span>
    <span class="token comment">/**
     * 消费者索引(当前消费进度).
     * 这是一个滞后值，消费者先消费可用槽位数据，再更新消费进度;
     */</span>
<span class="token keyword">protected</span> <span class="token keyword">long</span> consumerIndex<span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>跟进 offer() 方法的源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">E</span> e<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

       <span class="token comment">//producerLimit基于consumerIndex计算的一个缓存值，用户减少对consumerIndex的读取（减少缓存行miss），在循环中可能更新</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> mask <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mask<span class="token punctuation">;</span>
        <span class="token keyword">long</span> producerLimit <span class="token operator">=</span> <span class="token function">lvProducerLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> pIndex<span class="token punctuation">;</span>
        <span class="token keyword">do</span>
        <span class="token punctuation">{</span>
           <span class="token comment">//获取生产者索引</span>
            pIndex <span class="token operator">=</span> <span class="token function">lvProducerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pIndex <span class="token operator">&gt;=</span> producerLimit<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment">// 生产者索引大于等于缓存的上限，表示根据缓存值认为队列已满。</span>
                <span class="token comment">// 此时，分两种情况：1. 队列真的满了。 2.缓存过期了。</span>
                <span class="token comment">// 因此需要读取最新的消费者索引，计算新的上限，判断队列是否是真的满了（以满足Queue对offer的语义要求）</span>
                
                <span class="token comment">// 获取消费者索引</span>
                <span class="token keyword">final</span> <span class="token keyword">long</span> cIndex <span class="token operator">=</span> <span class="token function">lvConsumerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//设计的很巧妙，仔细分析下。就是生产速度最大快于消费者一个容量的大小</span>
                <span class="token comment">//buffer 的大小=mask+1</span>
                producerLimit <span class="token operator">=</span> cIndex <span class="token operator">+</span> mask <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                
                <span class="token comment">//生产速度是否快于消费速度</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>pIndex <span class="token operator">&gt;=</span> producerLimit<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token comment">// 最新的消费者索引显式队列确实已满</span>
                    <span class="token comment">// 只有当producerLimit大于producerIndex时更新才有意义，因此不更新producerLimit。</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// FULL :(</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span>
                <span class="token punctuation">{</span>
                    <span class="token comment">// 更新producerLimit为下一个我们必须重新检查消费者索引的值</span>
                    <span class="token comment">// 因为是多生产者模式，因此更新缓存会产生竞争。</span>
                    <span class="token comment">// Q: 为什么竞争是良性的？</span>
                    <span class="token comment">// A: 因为producerLimit永远不会超过下一次的计算值，而producerLimit小于实际值并不会带来错误。</span>

                    <span class="token comment">// update producer limit to the next index that we must recheck the consumer index</span>
                    <span class="token comment">// this is racy, but the race is benign</span>
                    <span class="token function">soProducerLimit</span><span class="token punctuation">(</span>producerLimit<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">casProducerIndex</span><span class="token punctuation">(</span>pIndex<span class="token punctuation">,</span> pIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on
         * the index visibility to poll() we would need to handle the case where the element is not visible.
         */</span>
        <span class="token comment">// CAS 竞争成功，可以进行填充</span>
        <span class="token comment">// 提示：新的生产者索引值先于数组中的元素对其它线程可见。如果依赖于索引的可见性执行poll，我们将需要处理元素可能不可见的情况。</span>

        <span class="token comment">// 前面的CAS已经保证了对象的正确构造（安全发布），这里使用Ordered模式是保证尽快的可见性（volatile是立即的可见性）。</span>
        <span class="token comment">// 计算生产者索引在数组中下标</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> offset <span class="token operator">=</span> <span class="token function">calcCircularRefElementOffset</span><span class="token punctuation">(</span>pIndex<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向数组中放入数据</span>
        <span class="token function">soRefElement</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br></div></div><p>在初始化状态，producerLimit 与队列的容量是相等的，producerLimit = capacity = 4，而 producerIndex = consumerIndex = 0。接下来 Thread1 和 Thread2 并发向 MpscArrayQueue 中存放数据，如下图所示。</p> <p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/Mpsc-2.png" alt="image-20210826200206920"></p> <p>两个线程此时拿到的 producerIndex 都是 0，是小于 producerLimit 的。此时两个线程都会尝试使用 CAS 操作更新 producerIndex，其中必然有一个是成功的，另外一个是失败的。</p> <ol><li>假设 Thread-1 执行 CAS 操作成功，那么 Thread-2 失败后就会重新更新 producerIndex。</li> <li>Thread-1 更新后 producerIndex 的值为 1，由于 producerIndex 是 volatile 修饰的，更新后立刻对 Thread-2 可见。</li> <li>这里有一点需要注意的是，当前线程更新后的值是被其他线程使用，当 Thread-1 和 Thread-2 都通过 CAS 抢占成功后，它们拿到的 pIndex 分别是 0 和 1。接下来就是根据 pIndex 进行位运算计算得到数组对应的下标，然后通过 UNSAFE.putOrderedObject() 方法将数据写入到数组中，源码如下所示。</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">soRefElement</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>putOrderedObject() 使用了 StoreStore Barrier，对于 Store1，StoreStore，Store2 这样的操作序列，在 Store2 进行写入之前，会保证 Store1 的写操作对其他处理器可见。保证写入都是最新的。</p> <p>跟进源码 calcCircularRefElementOffset()</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">/**
     * 计算环形数组的指定（逻辑）索引对应的偏移量 - index为逻辑索引，需要转换为真实索引。
     * &lt;p&gt;
     * 环形数组(环形缓冲区)的空间是重复利用的，因此逻辑上的index需要转换为真正的index然后再计算。
     * 为了高效运算，假定了环形数组的长度都为2的整次幂，因此mask应该为数组长度减1，这样可以使用 '&amp;' 快速计算。
     * eg. 数组大小为16 index=17 mask=15 index &amp; mask =1 
     * REF_ARRAY_BASE 数组中第一个元素的偏移地址， REF_ELEMENT_SHIFT：数组中一个元素占用的大小
     * Note: circular arrays are assumed a power of 2 in length and the `mask` is (length - 1).
     *
     * @param index desirable element index
     * @param mask (length - 1)
     * @return the offset in bytes within the circular array for a given index
     */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calcCircularRefElementOffset</span><span class="token punctuation">(</span><span class="token keyword">long</span> index<span class="token punctuation">,</span> <span class="token keyword">long</span> mask<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">REF_ARRAY_BASE</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>index <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">REF_ELEMENT_SHIFT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="出队poll"><a href="#出队poll" class="header-anchor">#</a> 出队Poll</h4> <p>跟进poll()方法。方法作用移除队列的首个元素并返回，如果队列为空则返回 NULL</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 直接返回消费者索引 consumerIndex</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> cIndex <span class="token operator">=</span> <span class="token function">lpConsumerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 计算数组对应的偏移量</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> offset <span class="token operator">=</span> <span class="token function">calcCircularRefElementOffset</span><span class="token punctuation">(</span>cIndex<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 读取为本地变量，避免在接下来的volatile读之后重新读取</span>
        <span class="token comment">// Copy field to avoid re-reading after volatile load</span>
        <span class="token keyword">final</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>buffer<span class="token punctuation">;</span>

        <span class="token comment">// 注意：生产者先更新索引，再填充元素，因此这里必须处理时序问题</span>
        <span class="token comment">// 如果元素不为null，那么可以安全的消费，因为生产者索引一定可见，但是如果元素为null，那么则必须等待其不为null。</span>
        <span class="token comment">// Q: 校验element而不是生产者索引，有什么好处？</span>
        <span class="token comment">// A: 可以减少对生产者索引的读！如果元素可见，那么不必读取生产者索引，可以减少缓存行miss问题。</span>

        <span class="token comment">// If we can't see the next available element we can't poll</span>
        <span class="token class-name">E</span> e <span class="token operator">=</span> <span class="token function">lvRefElement</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// null == e 有以下可能：</span>
            <span class="token comment">// 1. 队列为空</span>
            <span class="token comment">// 2. 生产者已经CAS更新了生产者索引，但是尚未填充元素，或填充的元素尚不可见 - 此时需要等待生产者完成填充，因为队列的状态表示当前并不为空！</span>

            <span class="token comment">// 提示：如果生产者在CAS更新生产者索引之后填充元素之前被中断，在这种情况下，队列并不是真正的为空。其它生产者会在该元素之后继续填充队列。</span>

            <span class="token comment">/*
             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after
             * winning the CAS on offer but before storing the element in the queue. Other producers may go on
             * to fill up the queue after this element.
             */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cIndex <span class="token operator">!=</span> <span class="token function">lvProducerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment">// 队列不为空，需要自旋等待直到元素可见 - 这也是比relaxedPool开销大的原因</span>
                <span class="token keyword">do</span>
                <span class="token punctuation">{</span>
                    e <span class="token operator">=</span> <span class="token function">lvRefElement</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                <span class="token comment">// 消费者索引和生产者索引相同，证明队列确实为空</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 先消费元素，再更新消费者进度（因为生产者会先校验consumerIndex，因此可确保生产者不会覆盖数据）。</span>
        <span class="token comment">// 这里可以使用Plain模式赋值为null，因为生产者一定会在索引可见之后才填充元素，consumerIndex的发布可以保证这里也正确发布。</span>
        <span class="token function">spRefElement</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">soConsumerIndex</span><span class="token punctuation">(</span>cIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><p>因为只有一个消费者线程，所以整个 poll() 的过程没有 CAS 操作。poll() 方法核心思路：</p> <ol><li>是获取消费者索引 consumerIndex</li> <li>根据 consumerIndex 计算得出数组对应的偏移量</li> <li>将数组对应位置的元素取出并返回
<ol><li>队列为null，直接返回</li> <li>队列不为空，自旋直到获取到元素</li></ol></li> <li>将 consumerIndex 移动到环形数组下一个位置。</li></ol> <p>获取消费者索引以及计算数组对应的偏移量的逻辑与 offer() 类似，在这里就不赘述了。下面直接看下如何取出数组中 offset 对应的元素，跟进 lvElement() 方法的源码。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">E</span> <span class="token function">lvRefElement</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>获取数组元素的时候同样使用了 UNSAFE 系列方法，getObjectVolatile() 方法则使用的是 LoadLoad Barrier，对于 Load1，LoadLoad，Load2 操作序列，在 Load2 以及后续读取操作之前，会保证 Load1 的读取操作执行完毕，所以 getObjectVolatile() 方法可以保证每次读取数据都可以从内存中拿到最新值。</p> <p>与 offer() 相反，poll() 比较关注队列为空的情况。当调用 lvElement() 方法获取到的元素为 NULL 时，有两种可能的情况：</p> <ol><li>如果消费者索引 consumerIndex 等于生产者 producerIndex，说明队列为空。</li> <li>只要两者不相等，消费者需要等待生产者填充数据完毕。(在 offer()  中先更新索引，然后填充数据)</li></ol> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>对 MpscArrayQueue 的知识点做一个简单的总结。</p> <ul><li>通过大量填充 long 类型变量解决伪共享问题。</li> <li>环形数组的容量设置为 2 的次幂，可以通过位运算快速定位到数组对应下标。</li> <li>入队 offer() 操作中 producerLimit 的巧妙设计，大幅度减少了主动获取消费者索引 consumerIndex 的次数，性能提升显著。</li> <li>入队和出队操作中都大量使用了 UNSAFE 系列方法，针对生产者和消费者的场景不同，使用的 UNSAFE 方法也是不一样的。</li></ul> <h3 id="说明"><a href="#说明" class="header-anchor">#</a> 说明</h3> <p>相关测试实践已经上传github  <a href="https://github.com/fengmingli/awesome-java/tree/main/middleware/jctools" target="_blank" rel="noopener noreferrer">repo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h2> <ol start="2"><li><a href="https://github.com/JCTools/JCTools/wiki/Getting-Started-With-JCTools" target="_blank" rel="noopener noreferrer">Github wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener noreferrer">Java魔法类：Unsafe应用解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://ifeve.com/memory-barriers-or-fences/" target="_blank" rel="noopener noreferrer">内存屏障<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/JCTools/JCTools.git" target="_blank" rel="noopener noreferrer">Github repo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/fengmingli/edit/master/docs/01.云原生/11.编程语言/112.Java/112005.高性能队列JCTools.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=Queue" title="标签">#Queue</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/12/03, 22:49:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/d4307f/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">神奇的高性能无锁队列Disruptor</div></a> <a href="/pages/405ff8/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Linux内核之kfifo</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/d4307f/" class="prev">神奇的高性能无锁队列Disruptor</a></span> <span class="next"><a href="/pages/405ff8/">Linux内核之kfifo</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/97863b2244/"><div>
            云原生资源
            <!----></div></a> <span class="date">05-25</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/9786d0311/"><div>
            kafka版本迭代说明
            <!----></div></a> <span class="date">03-11</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/9786dd2/"><div>
            docker-compose 快速搭建kafka集群
            <!----></div></a> <span class="date">03-02</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:lifengming666@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/fengmingli" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2018-2023
    <span>LiFengMing | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.89da10ab.js" defer></script><script src="/assets/js/2.8e04b068.js" defer></script><script src="/assets/js/19.d6a4cc61.js" defer></script>
  </body>
</html>
