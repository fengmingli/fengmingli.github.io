<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【DTS】DTLE 初体验</title>
    <link href="/2022/02/19/middleware/dts/dtle%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2022/02/19/middleware/dts/dtle%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>如果读者对数据同步没什么概念，可以阅读笔者往期博文：</p><ul><li><a href="/2021/08/07/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%BC%80%E7%AF%87/" title="数据同步系列（一）：漫谈数据同步">数据同步系列（一）：漫谈数据同步</a></li></ul>          </div><h3 id="DTLE-快速开始"><a href="#DTLE-快速开始" class="headerlink" title="DTLE 快速开始"></a>DTLE 快速开始</h3><p>这里所有服务都使用 Docker 进行部署。没有 Docker 环境请先安装 <a href="https://docs.docker.com/engine/install/">Docker Install</a></p><ul><li><strong>环境准备</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># step-0：工具准备</span></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## json 格式化工具</span></span><br>yum -y install jq<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Mysql客户端</span></span><br>yum -y install mysql <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># step-1: 创建网络</span></span><br>docker network create dtle-net<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># step-2: 创建 dtle</span></span><br>docker run --name dtle-consul -p 8500:8500 --network=dtle-net -d consul:latest<br>docker run --name dtle -p 4646:4646 --network=dtle-net -d actiontech/dtle<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># step-3: 创建源端/目标端 MySQL</span></span><br>docker run --name mysql-src -e MYSQL_ROOT_PASSWORD=pass -p 33061:3306 --network=dtle-net -d mysql:5.7 --gtid-mode=ON --enforce-gtid-consistency=1 --log-bin=bin --server-id=1<br><br>docker run --name mysql-dst -e MYSQL_ROOT_PASSWORD=pass -p 33062:3306 --network=dtle-net -d mysql:5.7 --gtid-mode=ON --enforce-gtid-consistency=1 --log-bin=bin --server-id=2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## step-4：检查 Mysql是否联通</span></span> <br><span class="hljs-meta">&gt;</span><span class="bash"> mysql -h 127.0.0.1 -P 33061 -uroot -ppass -e <span class="hljs-string">&quot;select @@version\G&quot;</span></span><br>&lt; *************************** 1. row ***************************<br>@@version: 5.7.23-log<br><span class="hljs-meta"></span><br><span class="hljs-meta">&gt;</span><span class="bash"> mysql -h 127.0.0.1 -P 33062 -uroot -ppass -e <span class="hljs-string">&quot;select @@version\G&quot;</span></span><br>&lt; *************************** 1. row ***************************<br>@@version: 5.7.23-log<br></code></pre></div></td></tr></table></figure><p>到上面为止，环境就已经准备完成！</p><ul><li><strong>数据准备</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 在源端创建一个测试库与表：demo.demo_tbl</span></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 连接源端库</span></span><br>mysql -h 127.0.0.1 -P 33061 -uroot -ppass<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 创建库</span></span><br>create database demo;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 进入demo表；</span></span><br>usr demo;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 创建表</span></span><br>CREATE TABLE IF NOT EXISTS `demo_tbl`(<br>   `runoob_id` INT UNSIGNED AUTO_INCREMENT,<br>   `runoob_title` VARCHAR(100) NOT NULL,<br>   `runoob_author` VARCHAR(40) NOT NULL,<br>   PRIMARY KEY ( `runoob_id` )<br>)ENGINE=InnoDB DEFAULT CHARSET=utf8;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 插入测试数据</span></span><br>INSERT INTO demo_tbl ( runoob_id, runoob_title,runoob_author )VALUES( 1, &quot;test1&quot;,&quot;xm1&quot;);<br>INSERT INTO demo_tbl ( runoob_id, runoob_title,runoob_author )VALUES( 2, &quot;test2&quot;,&quot;xm2&quot;);<br>INSERT INTO demo_tbl ( runoob_id, runoob_title,runoob_author )VALUES( 3, &quot;test3&quot;,&quot;xm3&quot;);<br>INSERT INTO demo_tbl ( runoob_id, runoob_title,runoob_author )VALUES( 4, &quot;test4&quot;,&quot;xm3&quot;);<br>INSERT INTO demo_tbl ( runoob_id, runoob_title,runoob_author )VALUES( 5, &quot;test5&quot;,&quot;xm4&quot;);<br>INSERT INTO demo_tbl ( runoob_id, runoob_title,runoob_author )VALUES( 6, &quot;test6&quot;,&quot;xm4&quot;);<br>INSERT INTO demo_tbl ( runoob_id, runoob_title,runoob_author )VALUES( 7, &quot;test7&quot;,&quot;xm5&quot;);<br></code></pre></div></td></tr></table></figure><ul><li><strong>创建复制任务</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 准备文件job.json, 内容如下:</span></span><br>&#123;<br>  &quot;Job&quot;: &#123;<br>    &quot;ID&quot;: &quot;dtle-demo&quot;,<br>    &quot;Datacenters&quot;: [&quot;dc1&quot;],<br>    &quot;TaskGroups&quot;: [&#123;<br>        &quot;Name&quot;: &quot;src&quot;,<br>        &quot;Tasks&quot;: [&#123;<br>          &quot;Name&quot;: &quot;src&quot;,<br>          &quot;Driver&quot;: &quot;dtle&quot;,<br>          &quot;Config&quot;: &#123;<br>            &quot;Gtid&quot;: &quot;&quot;,<br>            &quot;ReplicateDoDb&quot;: [&#123;<br>             #复制demo.demo_tbl<br>              &quot;TableSchema&quot;: &quot;demo&quot;,<br>              &quot;Tables&quot;: [&#123;<br>                &quot;TableName&quot;: &quot;demo_tbl&quot;<br>              &#125;]<br>            &#125;],<br>            # 源端mysql 配置<br>            &quot;ConnectionConfig&quot;: &#123;<br>              &quot;Host&quot;: &quot;mysql-src&quot;,<br>              &quot;Port&quot;: 3306,<br>              &quot;User&quot;: &quot;root&quot;,<br>              &quot;Password&quot;: &quot;pass&quot;<br>            &#125;<br>          &#125;<br>        &#125;]<br>      &#125;, &#123;<br>        &quot;Name&quot;: &quot;dest&quot;,<br>        &quot;Tasks&quot;: [&#123;<br>          &quot;Name&quot;: &quot;dest&quot;,<br>          &quot;Driver&quot;: &quot;dtle&quot;,<br>          &quot;Config&quot;: &#123;<br>            #目标端 mysql 配置<br>            &quot;ConnectionConfig&quot;: &#123;<br>              &quot;Host&quot;: &quot;mysql-dst&quot;,<br>              &quot;Port&quot;: 3306,<br>              &quot;User&quot;: &quot;root&quot;,<br>              &quot;Password&quot;: &quot;pass&quot;<br>            &#125;<br>          &#125;<br>        &#125;]<br>    &#125;]<br>  &#125;<br>&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 提交复制任务</span></span><br>curl -XPOST &quot;http://127.0.0.1:4646/v1/jobs&quot; -d @job.json -s | jq<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 查看作业状态</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"> curl -XGET <span class="hljs-string">&quot;http://127.0.0.1:4646/v1/job/dtle-demo&quot;</span> -s | jq <span class="hljs-string">&#x27;.Status&#x27;</span></span><br>&lt; &quot;running&quot;<br></code></pre></div></td></tr></table></figure><ul><li><strong>结果验证</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 登录目标端库</span></span><br>mysql -h 127.0.0.1 -P 33062 -uroot -ppass<br><br>MySQL [(none)]&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| demo               |<br>| dtle               |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>6 rows in set (0.00 sec)<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 切换到demo库</span></span><br>MySQL [(none)]&gt; use demo;<br><br>MySQL [demo]&gt; show tables; <br>+----------------+<br>| Tables_in_demo |<br>+----------------+<br>| demo_tbl       |<br>+----------------+<br>1 row in set (0.00 sec)<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 查看demo_tbl 数据</span></span><br>MySQL [demo]&gt; select * from demo_tbl;<br>+-----------+--------------+---------------+<br>| runoob_id | runoob_title | runoob_author |<br>+-----------+--------------+---------------+<br>|         1 | test         | xxxx          |<br>|         2 | test         | xxxx          |<br>|         3 | test         | xxxx          |<br>|         4 | test         | xxxx          |<br>|         5 | test         | xxxx          |<br>|         6 | test         | xxxx          |<br>|         7 | test         | xxxx          |<br>+-----------+--------------+---------------+<br>7 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure><p>到这里 DTLE 的初体验就结束了，如果想了解更多 DTLE 用法，请阅读 <a href="https://actiontech.github.io/dtle-docs-cn/">官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>DTS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Skill】Json处理</title>
    <link href="/2021/11/02/toolkit/JsonHandler/"/>
    <url>/2021/11/02/toolkit/JsonHandler/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>先抛出一个问题：在 k8s 中，如果只知道 pod 的 uid 怎么可以快速的定位到是哪个pod？ </p>          </div><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于 <strong>面向对象</strong> 的开发者来说，每天的业务代码会遇到大量的 <code>JSON</code> 处理。常见的序列化工具包：gson<code>, </code>fastjson<code>, </code>jackson , and so on。但是对于Json 的解析处理，尤其是复杂的 JSON 字符串，经常需要花费很大的精力才得到预期的结果。那是否有什么彩蛋可以解决这个问题了，当然。今天主要推荐两种  JSON 处理工具：</p><ul><li><a href="https://stedolan.github.io/jq/">Jq 官网</a></li><li><a href="https://github.com/json-path/JsonPath">JsonPath 官网</a></li></ul><h3 id="Jq"><a href="#Jq" class="headerlink" title="Jq"></a>Jq</h3><p>相对 Jsonpath 而言，Jq 在 Linux，Mac，Windows  等操作系统中使用的比较多。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Linux：<strong>sudo apt-get install jq</strong></p><p>Max：<strong>brew install jq</strong></p><p>Windows：<strong>chocolatey install jq</strong></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>数组操作，获取 ownerReferences 数组的值</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;<br>jq &#x27;.metadata.ownerReferences[]&#x27; jq.json<br>//输出：42<br></code></pre></div></td></tr></table></figure></li><li><p>对象/数组 构造</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：&#123;&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ Primer&quot;, &quot;More JQ&quot;]&#125;<br>jq &#x27;&#123;user, title: .titles[]&#125;&#x27;<br>//输出：<br>&#123;<br>  &quot;user&quot;: &quot;stedolan&quot;,<br>  &quot;title&quot;: &quot;JQ Primer&quot;<br>&#125;<br>&#123;<br>  &quot;user&quot;: &quot;stedolan&quot;,<br>  &quot;title&quot;: &quot;More JQ&quot;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>获取值的长度</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：[[1,2], &quot;string&quot;, &#123;&quot;a&quot;:2&#125;, null]<br>jq &#x27;.[] | length&#x27;<br>//输出：<br>2<br>6<br>1<br>0<br></code></pre></div></td></tr></table></figure></li><li><p>获取数组中的键，关键字：keys</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：&#123;&quot;abc&quot;: 1, &quot;abcd&quot;: 2, &quot;Foo&quot;: 3&#125;<br>jq &#x27;keys&#x27;<br>//输出：<br>[<br>  &quot;Foo&quot;,<br>  &quot;abc&quot;,<br>  &quot;abcd&quot;<br>]<br></code></pre></div></td></tr></table></figure></li><li><p>多个过滤关键字，关键字：，</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：&#123; &quot;foo&quot;: 42, &quot;bar&quot;: &quot;something else&quot;, &quot;baz&quot;: true&#125;<br>jq &#x27;.foo, .bar&#x27;<br>//输出：<br>42<br>&quot;something else&quot;<br></code></pre></div></td></tr></table></figure></li><li><p>一个过滤器的管道输出到下一个过滤器，关键字：｜</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：[&#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;, &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;]<br>jq &#x27;.[] | .name&#x27;<br>//输出：<br>&quot;JSON&quot;<br>&quot;XML&quot;<br></code></pre></div></td></tr></table></figure></li><li><p>如果 foo 返回 true，则输入不变，关键字：  select(foo)</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：[1,5,3,0,7]<br>jq &#x27;map(select(. &gt;= 2))&#x27;<br>//输出：[5,3,7]<br></code></pre></div></td></tr></table></figure></li><li><p>为每个输入调用过滤器，关键字：map</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入[1,2,3]<br>jq &#x27;map(.+1)&#x27;<br>//输出[2,3,4]<br></code></pre></div></td></tr></table></figure></li><li><p>条件语句，关键字：if-then-else-end</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：2<br>jq &#x27;if . == 0 then &quot;zero&quot; elif . == 1 then &quot;one&quot; else &quot;many&quot; end&#x27;<br>//输出：&quot;many&quot;<br></code></pre></div></td></tr></table></figure></li><li><p>字符串插值，关键字：\()</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">//输入：42<br>jq &#x27;&quot;The input was \(.), which is one less than \(.+1)&quot;&#x27;<br>//输出：&quot;The input was 42, which is one less than 43&quot;<br></code></pre></div></td></tr></table></figure></li></ul><p>下面以一段 K8s 的一段原数据信息为例，进行实践。</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,<br>    <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;Pod&quot;</span>,<br>    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;annotations&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;kubernetes.io/psp&quot;</span>: <span class="hljs-string">&quot;ack.privileged&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/broker-configuration-hash&quot;</span>: <span class="hljs-string">&quot;9a38330f594413a27516f7a4153c7c77ed8a0306&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/clients-ca-cert-generation&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/cluster-ca-cert-generation&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/generation&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/inter-broker-protocol-version&quot;</span>: <span class="hljs-string">&quot;2.7&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/kafka-version&quot;</span>: <span class="hljs-string">&quot;2.7.0&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/log-message-format-version&quot;</span>: <span class="hljs-string">&quot;2.7&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/logging-appenders-hash&quot;</span>: <span class="hljs-string">&quot;e893ac9f32f7958042d1c82477e3484b0f8ebad5&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;creationTimestamp&quot;</span>: <span class="hljs-string">&quot;2021-10-11T22:19:13Z&quot;</span>,<br>        <span class="hljs-attr">&quot;generateName&quot;</span>: <span class="hljs-string">&quot;mk-falcon-kafka-&quot;</span>,<br>        <span class="hljs-attr">&quot;labels&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;app.kubernetes.io/instance&quot;</span>: <span class="hljs-string">&quot;mk-falcon&quot;</span>,<br>            <span class="hljs-attr">&quot;app.kubernetes.io/managed-by&quot;</span>: <span class="hljs-string">&quot;strimzi-cluster-operator&quot;</span>,<br>            <span class="hljs-attr">&quot;app.kubernetes.io/name&quot;</span>: <span class="hljs-string">&quot;kafka&quot;</span>,<br>            <span class="hljs-attr">&quot;app.kubernetes.io/part-of&quot;</span>: <span class="hljs-string">&quot;strimzi-mk-falcon&quot;</span>,<br>            <span class="hljs-attr">&quot;controller-revision-hash&quot;</span>: <span class="hljs-string">&quot;mk-falcon-kafka-57f85c8bd5&quot;</span>,<br>            <span class="hljs-attr">&quot;statefulset.kubernetes.io/pod-name&quot;</span>: <span class="hljs-string">&quot;mk-falcon-kafka-0&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/cluster&quot;</span>: <span class="hljs-string">&quot;mk-falcon&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/kind&quot;</span>: <span class="hljs-string">&quot;Kafka&quot;</span>,<br>            <span class="hljs-attr">&quot;strimzi.io/name&quot;</span>: <span class="hljs-string">&quot;mk-falcon-kafka&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;mk-falcon-kafka-0&quot;</span>,<br>        <span class="hljs-attr">&quot;namespace&quot;</span>: <span class="hljs-string">&quot;falcon-dev&quot;</span>,<br>        <span class="hljs-attr">&quot;ownerReferences&quot;</span>: [<br>            &#123;<br>                <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;apps/v1&quot;</span>,<br>                <span class="hljs-attr">&quot;blockOwnerDeletion&quot;</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">&quot;controller&quot;</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;StatefulSet&quot;</span>,<br>                <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;mk-falcon-kafka&quot;</span>,<br>                <span class="hljs-attr">&quot;uid&quot;</span>: <span class="hljs-string">&quot;30f35905-458d-4e0d-9316-9fdcdaceae78&quot;</span><br>            &#125;<br>        ],<br>        <span class="hljs-attr">&quot;resourceVersion&quot;</span>: <span class="hljs-string">&quot;119726597&quot;</span>,<br>        <span class="hljs-attr">&quot;selfLink&quot;</span>: <span class="hljs-string">&quot;/api/v1/namespaces/falcon-dev/pods/mk-falcon-kafka-0&quot;</span>,<br>        <span class="hljs-attr">&quot;uid&quot;</span>: <span class="hljs-string">&quot;b1b7091b-3c09-48e0-b015-25a22007f13b&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>首先将上面 JSON 字符串保存到 jq.json 文件中。</p></blockquote><ul><li><p>过滤器操作，获取指定 apiVersion 的值。语法：.${key}</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jq &#x27;.apiVersion&#x27; jq.json<br></code></pre></div></td></tr></table></figure></li><li><p>过滤器操作，获取指定子对象的 “strimzi.io/broker-configuration-hash” 的值。语法：.${key}.${key}</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jq &#x27;.metadata.annotations.&quot;strimzi.io/broker-configuration-hash&quot;&#x27; jq.json<br></code></pre></div></td></tr></table></figure></li></ul><p>注意：如果 key 包含/或者其他等等，请使用””字符串进行。</p><ul><li><p>如果知道 k8s 的 uid 反查到 pod 的名称。如果使用 jq 的话那就简单了。<strong>（回答上面抛出的问题）</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl get pod -A -o json | jq &#x27;.items[] | select(.metadata.uid == &quot;6a1c56b9-3885-4cfa-86a7-f31796404550&quot;)&#x27;|jq &#x27;.metadata.labels.&quot;statefulset.kubernetes.io/pod-name&quot;&#x27;<br><br>//拓展<br>uid=6a1c56b9-3885-4cfa-86a7-f31796404550,获取其他的pod的名称，指定 uid 就行<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="Jsonpath"><a href="#Jsonpath" class="headerlink" title="Jsonpath"></a>Jsonpath</h3><p>看过 K8s 源码的同学，对于 Jsonpath 肯定不陌生。通过非常简单的操作，就拿到想要的结果。 </p><p>Jsonpath 的语法跟 Jq 很像，这里就不做过多的啰嗦。直接按照官网的 Demo 实操就行</p><ul><li><a href="https://github.com/json-path/JsonPath">Java Jsonpath 实操指南</a></li><li><a href="https://github.com/oliveagle/jsonpath">Go Jsonpath 实操指南</a></li></ul><h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><ul><li><p><a href="https://jqplay.org/s/_7uGMWvmUh#">Jq 在线练习场</a></p></li><li><p><a href="https://www.ivtool.com/jsonpath-parser/">Jathpath 在线练习场</a></p></li><li><p><a href="https://stedolan.github.io/jq/manual/">Jq开发手册</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Golang】人性化Go语言库</title>
    <link href="/2021/10/11/golang/go-humanize/"/>
    <url>/2021/10/11/golang/go-humanize/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>最近在 Github 逛的时候，发现的一个人性化的Go语言库: go-humanize</p><p><a href="https://github.com/dustin/go-humanize">Github repo</a></p>          </div><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>首先通过 <code>go get</code> 命令获取这个Go语言库。</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/dustin/<span class="hljs-keyword">go</span>-humanize<br></code></pre></div></td></tr></table></figure><p>然后使用 <code>import</code> 导入 <code>&quot;github.com/dustin/go-humanize&quot;</code> 就可以使用。</p><h3 id="容量尺寸转换"><a href="#容量尺寸转换" class="headerlink" title="容量尺寸转换"></a>容量尺寸转换</h3><p>比如刚刚硬盘的例子，就可以很容使用 <code>humanize.Bytes</code> 函数转化：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;That file is %s.&quot;</span>, <span class="hljs-params">humanize</span>.Bytes(82854982)</span>) <br><span class="hljs-comment">// That file is 83 MB.</span><br><br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;That file is %s.&quot;</span>, <span class="hljs-params">humanize</span>.Bytes(82854982000)</span>)<br><span class="hljs-comment">//That file is 83 GB</span><br></code></pre></div></td></tr></table></figure><p>从上面例子可以看出：把一长串的字节数字转换为人类更容易理解的83MB。但是它能做的可不止转为 <code>MB</code> 还可以是KB、GB等，会根据字节的大小选择最合适的单位。</p><h3 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h3><p>时间的转换也是一样，如果一个时间换成 <code>3分钟之前</code> 、 <code>3天之前</code> 会比干巴巴的绝对时间更容易理解，使用 <code>humanize.Time</code> 函数就可以搞定.</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;This was touched %s.&quot;</span>, humanize<span class="hljs-selector-class">.Time</span>(<span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Now</span>()<span class="hljs-selector-class">.Add</span>(<span class="hljs-number">45</span>*<span class="hljs-selector-tag">time</span>.Minute)))<br>This was touched <span class="hljs-number">44</span> minutes from now<br><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;This was touched %s.&quot;</span>, humanize<span class="hljs-selector-class">.Time</span>(<span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Now</span>()<span class="hljs-selector-class">.Add</span>(<span class="hljs-number">7</span>*<span class="hljs-selector-tag">time</span>.Hour)))<br><span class="hljs-comment">//This was touched 6 hours from now</span><br></code></pre></div></td></tr></table></figure><p>这个函数和 <code>humanize.Bytes</code> 是一样的，它也会根据相对的时间，转换为 <code>xxx分钟前</code> <code>xxx小时前</code> 或者 <code>xxx 天前</code> 等等。</p><h2 id="千分位"><a href="#千分位" class="headerlink" title="千分位"></a>千分位</h2><p>我们在处理金额的时候，如果使用千分位，也就是逗号分隔，会更容易阅读，<code>humanize</code> 也提供了这一功能。</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">fmt</span><span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;You owe ￥%s.\n&quot;</span>, humanize.Comma(<span class="hljs-number">6582491</span>))<br><span class="hljs-comment">//You owe ￥6,582,491.</span><br></code></pre></div></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>go-humanize  很好的把很多机器识别的字节字符转为人类更容易理解的形式。在日志打印，告警提示等场景可以借鉴此等方式</p><p>上面只是抛砖引玉的展示了 go-humanize 部分优秀功能： 更多请参考官方文档：<a href="https://pkg.go.dev/github.com/dustin/go-humanize">doc</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Skill】如何避免工作尴尬</title>
    <link href="/2021/10/07/live/%E9%9C%80%E8%A6%81%E9%81%BF%E5%BC%80%E7%9A%84%E8%AF%8D%E6%B1%87/"/>
    <url>/2021/10/07/live/%E9%9C%80%E8%A6%81%E9%81%BF%E5%BC%80%E7%9A%84%E8%AF%8D%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>读《重来》有感：工作中如何不损害交流？</p>          </div><p>在工作中有些词汇永远不要去使用，他们不是那些不文明用语。例如：”得”、“必须”、“不能”、“简单”、“只要”、“只有”以及“赶快”。这些词汇会损害交流。他们就像憎恨的代名词，为良好的互动就留埋下了一个个地雷，耽误了项目的进展。</p><p>使用这些词汇后，交流便处于了 “非黑即白” 的状态下。但是真相往往不是非黑即白的。所以人们会感到沮丧，问题也会滋生，从而带来了不必要的压力和冲突。</p><p>以下就是他们的毛病所在：</p><p>得。很骚有什么东西是 “得” 去做的。不要说 “得” ，最好说 “也许” 或 “你对这个是什么看法？” 或是 “这个注意听起来怎么样？” 或是 “你觉得我们能不能这样？”</p><p>不能。当你说 “ 不能” 时，其实也许能行。有时候 “不能是相对的”，比如，“我们不能这样开始，因为这样不对”，另外一种说法则是 “我们不能再花时间在这上面了，因为我们必须开始”。 这两种说法都不是实情。或许可以再等等看，是吗？</p><p>简单。简单是用来形容别人工作的一个词。 “你做起来一定很简单，对吗？” 但是你要注意，很少有人用简单来形容自己的工作。对你来说，这表示 “让我们来看看该怎么做吧”  「但是对别人来说，这个词意味着 “给我搞定它！”」</p><p>这些词经常在工作讨论中蹦出来（你还要注意他们的近义词：“每个人”、“没有人”、“总是”、“绝不”）。一旦出口，想要寻找解决方案久难上加难了。这些词就是把自己逼上死角，你必须在二个相反的极端中选择一个，等于逼着你去和他们对着干，不留一丝余地。</p><p>尤其是当你把这些词连在一起使用时：“<strong>我们现在就得把这个功能加进去，没有这个功能我们就不做了，每个人都想要它，这只是小事一桩，所以应该很简单，你应该能够很快把它做出来</strong>” 着短短60多个字，却可引出多种假设，这就是祸害。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Kubernetes】K8s应用存储与存储卷</title>
    <link href="/2021/09/26/cncf/%E6%BC%AB%E8%B0%88k8s%E5%BA%94%E7%94%A8%E5%AD%98%E5%82%A8%E4%B8%8E%E5%AD%98%E5%82%A8%E5%8D%B7/"/>
    <url>/2021/09/26/cncf/%E6%BC%AB%E8%B0%88k8s%E5%BA%94%E7%94%A8%E5%AD%98%E5%82%A8%E4%B8%8E%E5%AD%98%E5%82%A8%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>众所周知，K8s 的持久化存储（Persistent Storage）保证了应用数据独立于应用生命周期而存在，那么是否也有如下的一些疑问：</p><ul><li>如果 pod 中的某一个容器在运行时异常退出，被 kubelet 重新拉起之后，如何保证之前容器产生的重要数据没有丢失？</li><li>如果同一个 pod 中的多个容器想要共享数据，应该如何去做？</li><li>K8s 内部的存储流程到底是怎样的？</li><li>PV、PVC、StorageClass、Kubelet、CSI 插件等之间的调用关系又如何？</li></ul>          </div><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><strong>in-tree</strong>：<ul><li>运行在 k8s 核心组件内部的存储插件；</li></ul></li><li><strong>out-of-tree</strong>：<ul><li>独立在 k8s 组件之外运行的存储插件；</li><li>主要是通过 gRPC 接口跟 k8s 组件交互，并且 k8s 提供了大量的 SideCar 组件来配合 CSI 插件实现丰富的功能</li></ul></li><li><strong>PV</strong>：PersistentVolume<ul><li>持久化<strong>存储卷资源</strong>，详细定义预挂载存储空间的各项指标；</li><li>无 Namesapces  限制，一般由 Admin 创建 PV；</li></ul></li><li><strong>PVC</strong>：PersistentVolumeClaim<ul><li>持久化<strong>存储卷声明</strong>，用户使用的存储接口，对存储细节无感知，属于某个 Namespaces 内；</li></ul></li><li><strong>StorageClass</strong>：<ul><li>存储类，创建PV存储模版类，即系统会按照 StorageClass 定义的存储模版创建存储卷（包括真实的存储空间与 PV 对象）；</li><li>无 Namesapces  限制，一般由 Admin 创建；</li><li>每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV</li></ul></li><li><strong>CSI</strong>：Container Storage Interface<ul><li>目的是定义行业标准的 “容器存储接口”，使存储供应商（SP）基于 CSI 标准开发的插件可以在不同容器编排（CO）系统中工作，CO 系统包括 Kubernetes、Mesos、Swarm 等。</li></ul></li></ul><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><ul><li><strong>PV Controller</strong>：<ul><li>负责 PV/PVC 绑定及周期管理，根据需求进行数据卷的 Provision/Delete 操作；</li></ul></li><li><strong>AD Controller</strong>：<ul><li>负责数据卷的 Attach/Detach 操作，将设备挂接到目标节点；</li></ul></li><li><strong>Kubelet</strong>：<ul><li>Kubelet 是在每个 Node 节点上运行的主要 “节点代理”，功能是 Pod 生命周期管理、容器健康检查、容器监控等；</li></ul></li><li><strong>Volume Manager</strong>：<ul><li>Kubelet 中的组件，负责管理数据卷的 Mount/Umount 操作（也负责数据卷的 Attach/Detach 操作，需配置kubelet 相关参数开启该特性）、卷设备的格式化等等；</li></ul></li><li><strong>Volume Plugins</strong>：<ul><li>存储插件，由存储供应商开发，目的在于扩展各种存储类型的卷管理能力，实现第三方存储的各种操作能力。</li><li>Volume Plugins 有 in-tree 和 out-of-tree 两种；</li></ul></li><li><strong>SideCar 组件</strong><ul><li><strong>External Provioner</strong>：<ul><li>External Provioner 是一种 sidecar 容器，作用是调用 Volume Plugins 中的 CreateVolume 和 DeleteVolume 函数来执行 Provision/Delete 操作。</li><li>因为 K8s 的 PV 控制器无法直接调用 Volume Plugins 的相关函数，故由 External Provioner 通过 gRPC 来调用；</li></ul></li><li><strong>External Attacher</strong>：<ul><li>External Attacher 是一种 sidecar 容器，作用是调用 Volume Plugins 中的 ControllerPublishVolume ControllerUnpublishVolume 函数来执行 Attach/Detach 操作。</li><li>因为 K8s 的 AD 控制器无法直接调用 Volume Plugins 的相关函数，故由 External Attacher 通过 gRPC 来调用。</li></ul></li></ul></li></ul><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>疑问中提到的（1）（2）两个场景，其实都可以借助 Volumes 来很好地解决，接下来首先看一下 Pod Volumes 的常见类型：</p><ol><li>本地存储，常用的有 emptydir/hostpath；</li><li>网络存储：网络存储当前的实现方式有两种，一种是 in-tree，另一种是 out-of-tree ；</li><li>Projected Volumes：它其实是将一些配置信息，如 secret/configmap 用卷的形式挂载在容器中，让容器中的程序可以通过POSIX接口来访问配置数据；</li><li><strong>PV 与 PVC 就是今天要重点介绍的内容</strong>。</li></ol><h2 id="静态、动态存储卷"><a href="#静态、动态存储卷" class="headerlink" title="静态、动态存储卷"></a>静态、动态存储卷</h2><p>从上面的讨论我们知道了存储的相关基本概念，也知道了 PVC  是针对应用服务对存储的二次抽象，具有简洁的存储定义接口。而 PV 是具有繁琐存储细节的存储抽象，一般有专门的集群管理人员定义、维护。</p><p>根据 PV 的创建方式可以将存储卷分为<strong>动态存储</strong>和静态存储卷：</p><ul><li><strong>静态存储卷</strong>：由管理员创建的 PV</li><li><strong>动态存储卷</strong>：由 Provisioner 插件创建的 PV</li></ul><h3 id="静态存储卷"><a href="#静态存储卷" class="headerlink" title="静态存储卷"></a>静态存储卷</h3><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/staticVolumeProvisioning.png" alt="静态存储卷"></p><p><strong>静态 Provisioning：</strong></p><ul><li>首先集群管理员事先去规划这个集群中的用户会怎样使用存储，它会先预分配一些存储，也就是预先创建一些 PV；</li><li>然后用户在提交自己的存储需求（也就是 PVC）的时候，K8s 内部相关组件会帮助它把 PVC 和 PV 做绑定；</li><li>最后用户再通过 pod 去使用存储的时候，就可以通过 PVC 找到相应的 PV，它就可以使用了。</li></ul><p><strong>静态产生方式有什么不足呢？</strong></p><p>上图可以看到，首先需要集群管理员预分配，预分配其实是很难预测用户真实需求的。</p><p>举一个最简单的例子：如果用户需要的是 20G，然而集群管理员在分配的时候可能有 80G 、100G 的，但没有 20G 的，这样就很难满足用户的真实需求，也会造成资源浪费。有没有更好的方式呢？</p><h3 id="动态存储卷"><a href="#动态存储卷" class="headerlink" title="动态存储卷"></a>动态存储卷</h3><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/dynamicVolumeProvisioning.png" alt="动态存储卷"></p><p><strong>动态Provisioning是什么意思呢？</strong></p><ul><li><p>就是说现在集群管理员不预分配 PV，他写了一个创建 PV 的模板文件（StorageClass），这个模板文件是用来表示创建某一类型存储（块存储，文件存储等）所需的一些参数，这些参数是用户不关心的，给存储本身实现有关的参数。</p></li><li><p>用户只需要提交自身的存储需求，也就是 PV C文件，并在 PVC  中指定使用的存储模板（StorageClass）。</p></li><li><p>K8s 集群中的管控组件，会结合 PVC 和 StorageClass 的信息动态，生成用户所需要的存储（PV），将 PVC 和 PV 进行绑定后，pod 就可以使用 PV 了。通过 StorageClass 配置生成存储所需要的存储模板，再结合用户的需求动态创建 PV 对象，做到按需分配，在没有增加用户使用难度的同时也解放了集群管理员的运维工作。</p></li></ul><p>下面看一下 StorageClass 模板文件yaml：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>    name: csi-local<br>provisioner: localplugin.csi.alibabacloud.com<br>parameters:<br>    volumeType: LVM<br>    vgName: vg_longbridge<br>    fsType: ext4<br>    lvmType: &quot;striping&quot;<br>reclaimPolicy: Delete<br>volumeBindingMode: WaitForFirstConsumer<br>allowVolumeExpansion: true<br></code></pre></div></td></tr></table></figure><p>这个模板文件叫 StorageClass，在StorageClass里面，我们需要填的重要信息：</p><ul><li> provisioner，provisioner 是什么？它其实就是说我当时创建 PV 和对应的存储的时候，应该用哪个存储插件来去创建（其实就是 <strong>external-provisioner</strong> sidecar container是一个controller去watch pvc/pv对象，当新建一个由storageclass创建pv的pvc(或删除pv对象)，该sidecar container会grpc调用存储供应商开发的 csi-plugin CreateVolume(DeleteVolume)方法来实际创建一个外部存储volume，并新建一个pv对象写入k8s api server）。</li><li>这些参数是通过k8s创建存储的时候，需要指定的一些细节参数。对于这些参数，用户是不需要关心的，像这里 volumeType、vgName、fsType 和它的类型。</li><li>reclaimPolicy跟我们刚才讲解的 PV 里的意思是一样的，就是说动态创建出来的这块 PV,当使用方使用结束、Pod 及 PVC 被删除后，这块 PV 应该怎么处理，我们这个地方写的是 delete，意思就是说当使用方 pod 和 PVC 被删除之后，这个 PV 也会被删除掉。</li></ul><h3 id="PV-Controller-介绍"><a href="#PV-Controller-介绍" class="headerlink" title="PV Controller 介绍"></a>PV Controller 介绍</h3><p>此处借鉴 @郡宝 在<a href="https://edu.aliyun.com/lesson_1651_13092#_13092">云原生存储课程</a>中的流程图。</p><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/pvc.png"></p><p><strong>PV Controller 主要任务：</strong></p><ul><li>PV、PVC 生命周期管理：创建、删除PV对象；负责PV、PVC的状态迁移</li><li>绑定 PVC、PV 对象；一个 PVC 必须与一个 PV 绑定后才能被应用使用，PV-Controller 会根据绑定条件和对象状态对 PV、PVC 进行Bound、Unbound 操作。</li></ul><p><strong>PV 控制器中有两个 Worker：</strong></p><ul><li>ClaimWorker：处理 PVC 的 add /update/delete 相关事件以及 PVC 的状态迁移；</li><li>VolumeWorker：负责 PV 的状态迁移。</li></ul><p><strong>PV 状态迁移（UpdatePVStatus）</strong>：</p><p>在分析 PV状态迁移 之前，我们先了解下 PV 的回收策略。PV 的回收策略向集群阐述了在 PVC 释放卷的时候，应如何进行后续工作，目前可以采用三种策略：</p><ul><li>1、保留（Retain）：回收策略Retain使得用户可以手动回收资源。当 PersistentVolumeClaim 对象被删除时，PersistentVolume 卷仍然存在，对应的数据卷被视为”已释放（released）”。 由于卷上仍然存在着前一申领人的数据，该卷还不能用于其他申领。 管理员可以通过下面的步骤来手动回收该卷：</li><li>2、删除（Delete）：对于支持Delete回收策略的卷插件，删除动作会将 PersistentVolume 对象从 Kubernetes 中移除，同时也会从外部基础设施中移除所关联的存储资产。 动态供应的卷会继承其 StorageClass 中设置的回收策略，该策略默认 为Delete。如果插件能够支持，回收策略会执行基础的擦除操作（<code>rm -rf /thevolume/*</code>），这一卷就能被重新申请了。</li><li>3、回收（Recycle）：警告：回收策略Recycle已被废弃。取而代之的建议方案是使用动态供应。</li></ul><p>然后看下卷的阶段（Phase）：</p><ul><li><strong>Available</strong>：可用资源，尚未被绑定到 PVC 上</li><li><strong>Bound</strong>：该卷已经被绑定</li><li><strong>Released</strong>：PVC 已经被删除，但该资源尚未被集群回收</li><li><strong>Failed</strong>：该卷的自动回收过程失败。</li></ul><p>最后由 PV 状态迁移图可知：</p><ol><li>PV 初始状态为 Available，当 PV 与 PVC 绑定后，状态变为 Bound；</li><li>与 PV 绑定的 PVC 删除后，状态变为 Released；</li><li>当 PV 回收策略为 Recycle 或手动删除 PV 的 .Spec.ClaimRef 后，PV 状态变为 Available；</li><li>当 PV 回收策略未知或 Recycle 失败或存储卷删除失败，PV 状态变为 Failed；</li><li>手动删除 PV 的 .Spec.ClaimRef，PV 状态变为 Available。</li></ol><p><strong>PVC 状态迁移（UpdatePVCStatus）：</strong></p><p>首先看下 PVC 的阶段（Phase）：</p><ul><li><strong>Pending</strong>：可用资源，尚未被绑定到 PVC 上</li><li><strong>Bound</strong>：该卷已经被绑定</li><li><strong>Released</strong>：PVC 已经被删除，但该资源尚未被集群回收</li><li><strong>Failed</strong>：该卷的自动回收过程失败。</li></ul><p>最后由 PVC 状态迁移图可知：</p><ol><li><p>当集群中不存在满足 PVC 条件的 PV 时，PVC 状态为 Pending。在 PV 与 PVC 绑定后，PVC 状态由 Pending 变为 Bound；</p></li><li><p>与 PVC 绑定的 PV 在环境中被删除，PVC 状态变为 Lost；</p></li><li><p>再次与一个同名 PV 绑定后，PVC 状态变为 Bound。</p></li></ol><h2 id="CSI介绍"><a href="#CSI介绍" class="headerlink" title="CSI介绍"></a>CSI介绍</h2><p>csi 是什么？csi 的全称是 container storage interface，它是K8s社区后面对存储插件实现(out of tree)的官方推荐方式。csi 的实现大体可以分为两部分：</p><ul><li>第一部分是由k8s社区驱动实现的通用的部分， csi-provisioner controller 和 csi-attacher controller；</li><li>另外一种是由云存储厂商实践的，对接云存储厂商的 OpenApi，主要是实现真正的 create/delete/mount/unmount 存储的相关操作，csi-controller-server和csi-node-server。</li></ul><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/k8s-CSI.png" alt="k8s-csi"></p><p>这是阿里云的一张存储概况图，很好的说明了 CSI 插件支持静态存储卷挂载和动态存储卷挂载2种方式，在静态存储卷挂载的方式中，通常需要手动编辑和创建一个PV和PVC进行挂载。当需要PV和PVC数量很大的时候，您可以创建动态存储卷进行挂载。</p><h3 id="K8s-存储架构"><a href="#K8s-存储架构" class="headerlink" title="K8s 存储架构"></a>K8s 存储架构</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/k8s-storage-ad.png" alt="image-20210926232042332"></h3><h3 id="PV、PVC-以及通过-csi-使用存储流程"><a href="#PV、PVC-以及通过-csi-使用存储流程" class="headerlink" title="PV、PVC 以及通过 csi 使用存储流程"></a>PV、PVC 以及通过 csi 使用存储流程</h3><blockquote><p>此处借鉴 @郡宝 在<a href="https://edu.aliyun.com/lesson_1651_13092#_13092">云原生存储课程</a>中的流程图。</p></blockquote><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/pv%26pvc%26cs.png"></p><p><strong>流程如下</strong>：</p><ol><li><p>用户创建了一个包含 PVC 的 Pod，该 PVC 要求使用动态存储卷；</p></li><li><p>Scheduler 根据 Pod 配置、节点状态、PV 配置等信息，把 Pod 调度到一个合适的 Worker 节点上；</p></li><li><p>PV 控制器 watch 到该 Pod 使用的 PVC 处于 Pending 状态，于是调用 Volume Plugin（in-tree）创建存储卷，并创建 PV 对象（out-of-tree 由 External Provisioner 来处理）；</p></li><li><p>AD 控制器发现 Pod 和 PVC 处于待挂接状态，于是调用 Volume Plugin 挂接存储设备到目标 Worker 节点上</p></li><li><p>在 Worker 节点上，Kubelet 中的 Volume Manager 等待存储设备挂接完成，并通过 Volume Plugin 将设备挂载到全局目录：/var/lib/kubelet/pods/[pod uid]/volumes/kubernetes.io~iscsi/[PV name]（以 iscsi 为例）；</p></li><li><p>Kubelet  <em>通过 Docker 启动</em> Pod 的 Containers，用 bind mount <strong>方式将已挂载到本地全局目录的卷映射到容器</strong> 中。</p></li></ol><p><strong>整个流程流程分别三个阶段</strong>：</p><p>从上图可知： pod 挂载 volume 的整个工作流程。整个流程流程分别三个阶段：Provision/Delete、Attach/Detach、Mount/Unmount，不过不是每个存储方案都会经历这三个阶段，比如 NFS 就没有 Attach/Detach 阶段。</p><p><strong>先来看 Provision 阶段，整个过程如上图所示。其中 extenal-provisioner 和 PVController 均 watch PVC 资源。</strong></p><p>1.当 PVController watch 到集群中有 PVC 创建时，会判断当前是否有 in-tree plugin 与之相符，如果没有则判断其存储类型为 out-of-tree 类型，于是给 PVC 打上注解 <code>volume.beta.kubernetes.io/storage-provisioner=&#123;csi driver name&#125;</code>；</p><p>2.当 extenal-provisioner watch 到 PVC 的注解 csi driver 与自己的 csi driver 一致时，调用 CSI Controller 的 <code>CreateVolume</code> 接口；</p><p>3.当 CSI Controller 的 <code>CreateVolume</code> 接口返回成功时，extenal-provisioner 会在集群中创建对应的 PV；</p><p>4.PVController watch 到集群中有 PV 创建时，将 PV 与 PVC 进行绑定。</p><p><strong>Attach 阶段是指将 volume 附着到节点上，整个过程如上图所示。</strong></p><p>1.ADController 监听到 pod 被调度到某节点，并且使用的是 CSI 类型的 PV，会调用内部的 in-tree CSI 插件的接口，该接口会在集群中创建一个 VolumeAttachment 资源；</p><p>2.external-attacher 组件 watch 到有 VolumeAttachment 资源创建出来时，会调用 CSI Controller 的 <code>ControllerPublishVolume</code> 接口</p><p>3.当 CSI Controller 的 <code>ControllerPublishVolume</code> 接口调用成功后，external-attacher 将对应的 VolumeAttachment 对象的 Attached 状态设为 true；</p><p>4.ADController watch 到 VolumeAttachment 对象的 Attached 状态为 true 时，更新 ADController 内部的状态 ActualStateOfWorld。</p><p><strong>最后一步将 volume 挂载到 pod 里的过程涉及到 kubelet。</strong></p><p>整个流程简单地说是，对应节点上的 kubelet 在创建 pod 的过程中，会调用 CSI Node 插件，执行 mount 操作。</p><h2 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">查看PVC<br>kubectl get pvc<br><br>查看PV<br>kubectl get pv<br><br>查看storageClass<br>kubectl get storageClass<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里为大家简单总结一下。</p><ul><li>K8s Volume是用户Pod保存业务数据的重要接口和手段</li><li>PVC和PV体系增强了K8s Volumes在多Pod共享/迁移/存储扩展等场景下的能力</li><li>PV（存储）的不同供给模式(static and dynamic)可以通过多种方式为集群中的Pod供给所需的存储</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kubernetes.io/zh/docs/concepts/storage/">https://kubernetes.io/zh/docs/concepts/storage/</a></li><li><a href="https://help.aliyun.com/document_detail/134722.html">https://help.aliyun.com/document_detail/134722.html</a></li><li><a href="https://support.huaweicloud.com/basics-cce/kubernetes_0030.html">https://support.huaweicloud.com/basics-cce/kubernetes_0030.html</a></li><li><a href="https://www.v2k8s.com/storage/t/105#3b0d1a">https://www.v2k8s.com/storage/t/105#3b0d1a</a></li><li><a href="https://www.v2k8s.com/kubernetes/t/217">https://www.v2k8s.com/kubernetes/t/217</a></li><li><a href="https://cloud.tencent.com/developer/article/1847424">https://cloud.tencent.com/developer/article/1847424</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PV</tag>
      
      <tag>PVC</tag>
      
      <tag>Volumes</tag>
      
      <tag>StorageClass</tag>
      
      <tag>csi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决新版谷歌chrome浏览器cookie跨域，cookie失效问题</title>
    <link href="/2021/09/20/faq/cookie_expired/"/>
    <url>/2021/09/20/faq/cookie_expired/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>最近，笔者公司开发同学反应，请求中使用了cookie和session，结果登录后自动设置的cookie无效，没有设置成功，但是在其他浏览器中显示是正常的。</p><p>这是因为chrome浏览器80以上的版本为了防止CSRF攻击而增加了SameSite规则，且默认为打开。</p><p>改设置会影响所有涉及到cookie的操作。</p><p>想要携带cookie，必须将SameSite设为禁用。</p><h3 id="cookie失效原因"><a href="#cookie失效原因" class="headerlink" title="cookie失效原因"></a><a href="https://www.cnblogs.com/tianma3798/p/13517336.html">cookie失效原因</a></h3><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>方案一：关闭浏览器配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">1.在chrome的地址栏输入：`chrome://flags/`。<br>2.在搜索栏中输入：`SameSite`。<br>3.将搜索到的`SameSite by default cookies`<br>这一项由`Default`更改为`Disabled`。重启浏览器即可<br></code></pre></div></td></tr></table></figure><p>方案二：设置请求头</p><div class="note note-success">            <p>注意： 设置 SameSite=None;必须设置 Secure，否则不生效</p>          </div><figure class="highlight shell"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Set-Cookie: widget_session=abc123; SameSite=None; Secure<br></code></pre></div></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>由于 Cookie 中并没有 sameSite 属性，因此对Cookie 进行拓展。</p><p>Step 1: 拓展 Cookie 核心类</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cookie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String sameSite;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CookieWrapper</span><span class="hljs-params">(String name, String value)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSameSite</span><span class="hljs-params">(String sameSite)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sameSite = sameSite;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSameSite</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sameSite;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Step 2: 新增 Cookie 核心方法</p><div class="note note-success">            <p>注意：</p><ul><li>secure &amp; sameSite 必须同时设置，不然只设置 sameSite 将不生效。</li><li>原生 servlet 提供的 Cookie 没有 SameSite 属性，因此 Cookie 通过 addHeader 的方式添加。</li></ul>          </div><figure class="highlight java"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(CookieContext cookieContext)</span> </span>&#123;<br>    CookieWrapper cookie = <span class="hljs-keyword">new</span> CookieWrapper(cookieContext.getName(), cookieContext.getValue());<br>    <span class="hljs-keyword">if</span> (cookieContext.getPath() != <span class="hljs-keyword">null</span>) &#123;<br>        cookie.setPath(cookieContext.getPath());<br>    &#125;<br>    cookie.setHttpOnly(<span class="hljs-keyword">true</span>);<br>  <br>    <span class="hljs-comment">// secure &amp; sameSite must be set together</span><br>    cookie.setSecure(<span class="hljs-keyword">true</span>);<br>    cookie.setSameSite(cookieContext.getSameSite());<br>  <br>    String header = CookieSameSiteSupport.generateHeader(cookie);<br>    cookieContext.getResponse().addHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>,header);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>详细代码实现</strong>：<a href="https://github.com/fengmingli/awesome-java/blob/main/middleware/sso/src/main/java/com/lifengming/sso/common/CookieHelper.java">Github repo</a></p>]]></content>
    
    
    <categories>
      
      <category>FAQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cookie</tag>
      
      <tag>SSO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Golang】Golang 编码最佳实践</title>
    <link href="/2021/09/05/golang/go-best-practice/"/>
    <url>/2021/09/05/golang/go-best-practice/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-语言实战-编写可维护-Go-语言代码建议"><a href="#Go-语言实战-编写可维护-Go-语言代码建议" class="headerlink" title="Go 语言实战: 编写可维护 Go 语言代码建议"></a>Go 语言实战: 编写可维护 Go 语言代码建议</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#1-%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99">1. 指导原则</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#11-%E7%AE%80%E5%8D%95%E6%80%A7">1.1 简单性</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#12-%E5%8F%AF%E8%AF%BB%E6%80%A7">1.2 可读性</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#13-%E7%94%9F%E4%BA%A7%E5%8A%9B">1.3 生产力</a></li></ul></li><li><a href="https://github.com/llitfkitfk/go-best-practice#2-%E6%A0%87%E8%AF%86%E7%AC%A6">2. 标识符</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#21-%E9%80%89%E6%8B%A9%E6%A0%87%E8%AF%86%E7%AC%A6%E6%98%AF%E4%B8%BA%E4%BA%86%E6%B8%85%E6%99%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E7%AE%80%E6%B4%81">2.1 选择标识是为了清晰, 而不是简洁</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#22-%E6%A0%87%E8%AF%86%E7%AC%A6%E9%95%BF%E5%BA%A6">2.2 标识符长度</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#23-%E4%B8%8D%E8%A6%81%E7%94%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%91%BD%E5%90%8D%E4%BD%A0%E7%9A%84%E5%8F%98%E9%87%8F">2.3 不要用变量类型命名变量</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#24-%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F">2.4 使用一致的命名风格</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#25-%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E7%9A%84%E5%A3%B0%E6%98%8E%E6%A0%B7%E5%BC%8F">2.5 使用一致的声明样式</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#26-%E6%88%90%E4%B8%BA%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C%E8%80%85">2.6 成为团队的合作者</a></li></ul></li><li><a href="https://github.com/llitfkitfk/go-best-practice#3-%E6%B3%A8%E9%87%8A">3. 注释</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#31-%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9A%84%E6%B3%A8%E9%87%8A%E5%BA%94%E6%8F%8F%E8%BF%B0%E5%85%B6%E5%86%85%E5%AE%B9%E8%80%8C%E9%9D%9E%E5%85%B6%E7%9B%AE%E7%9A%84">3.1 关于变量和常量的注释应描述其内容而非其目的</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#32-%E5%85%AC%E5%85%B1%E7%AC%A6%E5%8F%B7%E5%A7%8B%E7%BB%88%E8%A6%81%E6%B3%A8%E9%87%8A">3.2 公共符号始终要注释</a></li></ul></li><li><a href="https://github.com/llitfkitfk/go-best-practice#4-%E5%8C%85%E7%9A%84%E8%AE%BE%E8%AE%A1">4. 包的设计</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#41-%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E5%8C%85%E4%BB%8E%E5%AE%83%E7%9A%84%E5%90%8D%E5%AD%97%E5%BC%80%E5%A7%8B">4.1 一个好的包从它的名字开始</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#42-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BC-basecommon-%E6%88%96-util-%E7%9A%84%E5%8C%85%E5%90%8D%E7%A7%B0">4.2 避免使用类似 <code>base</code> 、<code>common</code> 或 <code>util</code> 的包名称</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#43-%E5%B0%BD%E6%97%A9-return-%E8%80%8C%E4%B8%8D%E6%98%AF%E6%B7%B1%E5%BA%A6%E5%B5%8C%E5%A5%97">4.3 尽早 <code>return</code> 而不是深度嵌套</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#44-%E8%AE%A9%E9%9B%B6%E5%80%BC%E6%9B%B4%E6%9C%89%E7%94%A8">4.4 让零值更有用</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#45-%E9%81%BF%E5%85%8D%E5%8C%85%E7%BA%A7%E5%88%AB%E7%8A%B6%E6%80%81">4.5 避免包级别状态</a></li></ul></li><li><a href="https://github.com/llitfkitfk/go-best-practice#5-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">5. 项目结构</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#51-%E8%80%83%E8%99%91%E6%9B%B4%E5%B0%91%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%8C%85">5.1 考虑更少，更大的包</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#52-%E7%A1%AE%E4%BF%9D-main-%E5%8C%85%E5%86%85%E5%AE%B9%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E5%B0%91">5.2 保持 <code>main</code> 包内容尽可能的少</a></li></ul></li><li><a href="https://github.com/llitfkitfk/go-best-practice#6-api-%E8%AE%BE%E8%AE%A1">6. API 设计</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#61-%E8%AE%BE%E8%AE%A1%E9%9A%BE%E4%BB%A5%E8%A2%AB%E8%AF%AF%E7%94%A8%E7%9A%84-api">6.1 设计难以被误用的 API</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#62-%E4%B8%BA%E5%85%B6%E9%BB%98%E8%AE%A4%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1-api">6.2 为其默认用例设计 API</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#63-%E8%AE%A9%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%AE%83%E4%BB%AC%E6%89%80%E9%9C%80%E7%9A%84%E8%A1%8C%E4%B8%BA">6.3 让函数定义它们所需的行为</a></li></ul></li><li><a href="https://github.com/llitfkitfk/go-best-practice#7-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">7. 错误处理</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#71-%E9%80%9A%E8%BF%87%E6%B6%88%E9%99%A4%E9%94%99%E8%AF%AF%E6%9D%A5%E6%B6%88%E9%99%A4%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">7.1 通过消除错误来消除错误处理</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#72-%E9%94%99%E8%AF%AF%E5%8F%AA%E5%A4%84%E7%90%86%E4%B8%80%E6%AC%A1">7.2 错误只处理一次</a></li></ul></li><li><a href="https://github.com/llitfkitfk/go-best-practice#8-%E5%B9%B6%E5%8F%91">8. 并发</a><ul><li><a href="https://github.com/llitfkitfk/go-best-practice#81-%E4%BF%9D%E6%8C%81%E8%87%AA%E5%B7%B1%E5%BF%99%E7%A2%8C%E6%88%96%E5%81%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B7%A5%E4%BD%9C">8.1 保持自己忙碌或做自己的工作</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#82-%E5%B0%86%E5%B9%B6%E5%8F%91%E6%80%A7%E7%95%99%E7%BB%99%E8%B0%83%E7%94%A8%E8%80%85">8.2 将并发性留给调用者</a></li><li><a href="https://github.com/llitfkitfk/go-best-practice#83-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%81%9C%E6%AD%A2%E4%B8%8D%E4%BA%86%E7%9A%84-goroutine">8.3 永远不要启动一个停止不了的 <code>goroutine</code></a></li></ul></li></ul><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><ul><li><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a></p></li><li><p><a href="https://github.com/llitfkitfk/go-best-practice">https://github.com/llitfkitfk/go-best-practice</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据同步系列：方案选型</title>
    <link href="/2021/08/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/"/>
    <url>/2021/08/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>系列文章：</p><ul><li><a href="/2021/08/07/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%BC%80%E7%AF%87/" title="数据同步系列（一）：漫谈数据同步">数据同步系列（一）：漫谈数据同步</a></li><li><a href="/2021/08/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/" title="数据同步系列（二）：数据同步方案选型">数据同步系列（二）：数据同步方案选型</a></li><li><a href="/2021/07/30/middleware/kafka/kafkaConnect/" title="数据同步系列（三）：什么是kafka connect">数据同步系列（三）：什么是kafka connect</a></li><li><a href="/2021/07/26/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BF%9D%E8%AF%81/" title="数据同步系列（四）：数据同步之高可用">数据同步系列（四）：数据同步之高可用</a></li><li><a href="/2021/07/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81/" title="数据同步系列（五）：数据同步之数据一致性">数据同步系列（五）：数据同步之数据一致性</a></li><li><a href="/2021/07/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/" title="数据同步系列（六）：数据同步之部署">数据同步系列（六）：数据同步之部署</a></li><li><a href="/2021/07/26/middleware/kafka/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/" title="数据同步系列（七）：数据同步之踩坑">数据同步系列（七）：数据同步之踩坑</a></li></ul>          </div><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数据准实时复制（CDC）是目前行内实时数据需求大量使用的技术。本文把市面上常见的几种开源产品：Canal、Debezium、Flink CDC、DataX、Kettle、Oracle GoldenGate 供大家参考。</p><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><ul><li>自建开源方案对比</li></ul><table><thead><tr><th align="left"></th><th>Fink CDC</th><th>Debeizum</th><th>DataX</th><th>Canal</th><th>kettle</th><th>Oracle GoldenGate</th></tr></thead><tbody><tr><td align="left"><strong>CDC机制</strong></td><td>binlog日志</td><td>binlog日志</td><td>查询</td><td>binlog日志</td><td>查询</td><td>binlog日志</td></tr><tr><td align="left"><strong>断点续传</strong></td><td>支持</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td align="left"><strong>增量同步</strong></td><td>支持</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td align="left"><strong>全量同步</strong></td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td align="left"><strong>全量+增量</strong></td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td align="left"><strong>架构</strong></td><td>分布式</td><td>单机</td><td>单机</td><td>单机</td><td>分布式</td><td>分布式</td></tr><tr><td align="left"><strong>生态</strong></td><td>⭐️⭐️⭐️⭐️⭐️</td><td>⭐️⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️</td><td>⭐️⭐️⭐️</td></tr></tbody></table><ul><li>商业化产品</li></ul><table><thead><tr><th></th><th><a href="https://doc.clougence.com/docs/en/product_intro">CloudCanal</a></th><th><a href="https://cloud.tapdata.net/">Tapdata Cloud</a></th><th><a href="https://help.aliyun.com/document_detail/211599.html">阿里云DTS</a></th></tr></thead><tbody><tr><td>部署方式</td><td>公有云，本地化部署</td><td>公有云，自建实例，本地化部署</td><td>云服务</td></tr><tr><td>全量同步</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>增量同步</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>全量+增量</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>消息订阅</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>结构迁移</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据Check</td><td>支持</td><td>支持三种数据 Check 方式：<br />1、全量 <br />2、全表字段值校验 <br />3、关联字段值校验</td><td>不支持</td></tr><tr><td>开源版本</td><td>开源版本免费试用</td><td>开源版本永久免费</td><td>开源版本 Canal，需要自行维护</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于数据同步技术的选型，可以从以下几方面考虑：</p><ul><li>业务支持度（功能）</li><li>成本（资源成本与运维成本）</li><li>技术栈</li><li>社区活跃度</li></ul><p>云服务商与开源/自建比较：</p><table><thead><tr><th></th><th>云服务商</th><th>开源二开/自建</th></tr></thead><tbody><tr><td>资源成本</td><td>根据同步任务收费，跟同步业务量有关。<br />收费是一个长期的过程</td><td>机器成本，前期投入高</td></tr><tr><td>维护成本</td><td>人员投入少，出现问题可以直接找云厂商解决</td><td>需要自己维护，投入人员较多且周期长</td></tr><tr><td>功能迭代</td><td>满足大部分功能，特殊需求可以定制化</td><td>完全自己掌控，可快速迭代</td></tr><tr><td>开发周期</td><td>周期短，能很快接入</td><td>开发周期长，需要从 0 到 1</td></tr><tr><td>技术沉淀</td><td>技术沉淀较少</td><td>有较丰富的底层技术沉淀</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据同步</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac系统设置永久生效的别名</title>
    <link href="/2021/08/10/toolkit/mac_alias/"/>
    <url>/2021/08/10/toolkit/mac_alias/</url>
    
    <content type="html"><![CDATA[<h1 id="当前登录有效"><a href="#当前登录有效" class="headerlink" title="当前登录有效"></a>当前登录有效</h1><ol><li>直接在本次登录的命令命令行中输入：alias ll=’ls -l’</li><li>取消的命令为：unalias ll</li></ol><h1 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h1><ol><li>在当前用户下执行：vim ~/.bashrc 写入alias ll=’ls -l’ 并保存关闭；</li><li>vim ~/.bash_profile 加入：source ~/.bashrc 使其生效</li><li>重启在命令行输入ll就可以看到效果了</li></ol>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据同步系列：漫谈数据同步</title>
    <link href="/2021/08/07/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%BC%80%E7%AF%87/"/>
    <url>/2021/08/07/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%BC%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>取消大小周了！！！当时听到这个消息的时候不相信。当确定消息真伪之后，心想着终于有更多的时间去干自己喜欢的事情了。总结是对自己过去工作最大的肯定。</p><p>系列文章：</p><ul><li><a href="/2021/08/07/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%BC%80%E7%AF%87/" title="数据同步系列（一）：漫谈数据同步">数据同步系列（一）：漫谈数据同步</a></li><li><a href="/2021/08/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/" title="数据同步系列（二）：数据同步方案选型">数据同步系列（二）：数据同步方案选型</a></li><li><a href="/2021/07/30/middleware/kafka/kafkaConnect/" title="数据同步系列（三）：什么是kafka connect">数据同步系列（三）：什么是kafka connect</a></li><li><a href="/2021/07/26/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BF%9D%E8%AF%81/" title="数据同步系列（四）：数据同步之高可用">数据同步系列（四）：数据同步之高可用</a></li><li><a href="/2021/07/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81/" title="数据同步系列（五）：数据同步之数据一致性">数据同步系列（五）：数据同步之数据一致性</a></li><li><a href="/2021/07/30/middleware/kafka/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/" title="数据同步系列（六）：数据同步之部署">数据同步系列（六）：数据同步之部署</a></li><li><a href="/2021/07/26/middleware/kafka/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/" title="数据同步系列（七）：数据同步之踩坑">数据同步系列（七）：数据同步之踩坑</a></li></ul>          </div><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数据已成为企业极其重要的资产，数据同步也成为企业数据开发和使用一个绕不过去的技术需求。</p><ul><li>什么时候我们需要进行数据同步，甚至是实时同步呢？</li><li>目前又有什么实时同步方案？</li></ul><h3 id="什么是数据同步"><a href="#什么是数据同步" class="headerlink" title="什么是数据同步"></a>什么是数据同步</h3><p>帮助用户实现两个或多个数据源之间的数据搬运工具。不生产消息，只是消息的搬运工。</p><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>知道了数据同步解决了什么问题，哪些业务场景会使用到数据同步了。</p><ul><li><p><strong>数据库异地灾备</strong></p><p>​        以传统金融机构数据中心为例，单数据中心由于地理约束等不能抵抗不可预知与控制的风险，已不能满足金融监管要求和企业业务敏捷的诉求，灾备甚至双活成为一个典型的刚性需求。实时数据同步是实现异地灾备的核心能力。</p></li><li><p><strong>不停机迁移数据库</strong></p><p>​        系统升级迁移是运维同事的日常工作之一。传统的方式，需要对存量的数据库做一个迁移，耗时非常久。如果基于这种实时同步这种模式，且有相应的产品去做支撑，就能保证我们的数据在迁移和做应用切换的时候，可以进行平滑的调整，把窗口尽量压缩，从小时级缩短到分钟级。</p></li><li><p><strong>数据实时入仓/湖</strong></p><p>​        在做数据仓库建设时，我们需要将大量业务系统数据持续集成到数据仓库/数据湖。我们要把数据从原有的各种各样的数据库里面，把它能够放到数据仓库里面去。</p><p>​        数据仓库更多是用来出报表，而不是去支持在线业务，这也是为什么近几年企业会越来越希望通过数据中台或者这种类似的实时数据能力，去加速整个数据在企业内的应用和流转。</p></li><li><p><strong>读写分离</strong></p><p>​        举个银行账单系统的例子。我们平常去刷信用卡，我们刷一笔，银行同时会记录一笔，同时我们可能还会不定期的去查询交易记录，这样的话从技术角度上来说，读和写我们需要能够分离，去保证整个系统的效率最大化。</p></li><li><p><strong>业务异步解耦</strong></p><p>​        一个典型的问题就是如果所有的系统都是一个个孤岛，但业务是需要联通的，这个时候需要打通不同的系统之间的数据。但是我们发现，系统是由不同的技术栈开发的，处理系统间的扩展，这样成本非常高。大家现在多会怎么做呢？如果使用实时数据同步，再加上一定的数据开发的能力，就可以很好的来管理和解决这些问题。</p></li></ul><p>对于上面的经典业务场景，我们归纳于以下两类：</p><ul><li><strong>数据异构</strong><ul><li>同源：原端与目标端数据结构一样，例如：mysql-&gt;mysql<ul><li>单表</li><li>多表（需要数据聚合）</li></ul></li><li>异源：原端与目标端数据结构不一样，例如：mysql-&gt;es<ul><li>单表</li><li>多表（需要数据聚合）</li></ul></li></ul></li><li><strong>消息订阅</strong><ul><li>当数据变更时需要通知其他依赖系统。</li><li>任务系统监听数据库变更，然后将变更的数据写入MQ/kafka进行任务下发，比如商品数据变更后需要通知商品详情页、列表页、搜索页等相关系统。</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>方面主要介绍了，我们知道了数据同步是什么？哪些经典的业务场景使用到了数据同步？下一篇文章将介绍数据同步技术方案的选型。</p>]]></content>
    
    
    <categories>
      
      <category>数据同步</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Elasticsearch】ES别名替换</title>
    <link href="/2021/07/30/middleware/elasticsearch/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/07/30/middleware/elasticsearch/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Elasticsearch 是我们日常使用的比较多的搜索引擎。掌握 Elasticsearch 的基本语法就显得格外重要了‼️</p><h2 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h2><ol><li>别名替换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apl">POST _aliases<br>&#123;<br> &quot;actions&quot;: [<br>   &#123;<br>     &quot;add&quot;: &#123;<br>       &quot;index&quot;: &quot;test1&quot;,<br>       &quot;alias&quot;: &quot;alias1&quot;<br>     &#125;<br>   &#125;,<br>   &#123;<br>     &quot;remove&quot;: &#123;<br>       &quot;index&quot;: &quot;test1&quot;,<br>       &quot;alias&quot;: &quot;alias1&quot;<br>     &#125;<br>   &#125;<br> ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2.更新文档中某一个值</p><p>可以使用script脚本功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apl">POST $&#123;indexName&#125;/$&#123;type&#125;/$&#123;docId&#125;/_update<br>&#123;<br> &quot;script&quot; : &quot;ctx._source.item_name=&#x27;123&#x27;&quot;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这就类似于sql的：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apl">UPDATE index_test SET item_name=‘123&#x27; WHERE id=3937;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kubernetes】K8s常见问题排查技巧</title>
    <link href="/2021/06/26/cncf/k8s%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/06/26/cncf/k8s%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p><strong>简介：</strong> 排查完全陌生的问题、完全不熟悉的系统组件，对于后端开发工程师来说是乐趣，当然也是挑战。今天借这篇文章，跟大家分析一例这样的问题。排查过程中，需要理解一些自己完全陌生的组件，比如 systemd 和 dbus。但是排查问题的思路和方法基本上还是可以复用了，希望对大家有所帮助。</p>          </div><h3 id="主节点相关操作"><a href="#主节点相关操作" class="headerlink" title="主节点相关操作"></a>主节点相关操作</h3><figure class="highlight shell"><table><tr><td class="gutter hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">更改配置文件，重新加载<br>systemctl daemon-reload<br>启动master相关组件<br>systemctl start kube-apiserver/kube-controller-manager/ube-scheduler/etcd.service<br>停止master相关组件<br>systemctl stop kube-apiserver/kube-controller-manager/ube-scheduler/etcd.service<br>重启master相关组件<br>systemctl restart kube-apiserver/kube-controller-manager/ube-scheduler/etcd.service<br>查看master相关组件状态<br>systemctl status kube-apiserver/kube-controller-manager/ube-scheduler/etcd.service<br>查看各组件信息<br>kubectl get componentstatuses<br>查看kubelet进程启动参数<br>ps -ef | grep kubelet<br>查看日志:<br>journalctl -u kubelet -f<br>查看集群信息<br>kubectl cluster-info<br></code></pre></div></td></tr></table></figure><h3 id="从节点相关操作"><a href="#从节点相关操作" class="headerlink" title="从节点相关操作"></a>从节点相关操作</h3><figure class="highlight shell"><table><tr><td class="gutter hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">启动worker端相关组件<br>systemctl start kube-proxy/docker/kubelet<br>停止worker端相关组件<br>systemctl stop kube-proxy/docker/kubelet<br>重启worker端相关组件<br>systemctl restart kube-proxy/docker/kubelet<br>查看worker端相关组件状态<br>systemctl status kube-proxy/docker/kubelet<br></code></pre></div></td></tr></table></figure><h3 id="节点相关操作"><a href="#节点相关操作" class="headerlink" title="节点相关操作"></a>节点相关操作</h3><figure class="highlight shell"><table><tr><td class="gutter hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">设为node为不可调度状态：<br>kubectl cordon node1<br>解除node不可调度状态<br>kubectl uncordon node1<br>将pod赶到其他节点：<br>kubectl drain node1<br>master运行pod<br>kubectl taint nodes master.k8s node-role.kubernetes.io/master-<br>master不运行pod<br>kubectl taint nodes master.k8s node-role.kubernetes.io/master=:NoSchedule<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag> Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何编写项目的 README.md</title>
    <link href="/2021/06/26/project/ReademeTemplate/"/>
    <url>/2021/06/26/project/ReademeTemplate/</url>
    
    <content type="html"><![CDATA[<h1 id="Project-Title"><a href="#Project-Title" class="headerlink" title="Project Title"></a>Project Title</h1><p>Simple overview of use/purpose.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ul><li>How/where to download your program</li><li>Any modifications needed to be made to files/folders</li></ul><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ul><li>How to run the program</li><li>Step-by-step bullets</li></ul><h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><ol><li>Fork it!</li><li>Create your feature branch: <code>git checkout -b my-new-feature</code></li><li>Commit your changes: <code>git commit -am &#39;Add some feature&#39;</code></li><li>Push to the branch: <code>git push origin my-new-feature</code></li><li>Submit a pull request :D</li></ol><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><ul><li>0.2<ul><li>Various bug fixes and optimizations</li><li>See <a href="https://gist.github.com/DomPizzie/7a5ff55ffa9081f2de27c315f5018afc">commit change</a> or See <a href="https://gist.github.com/DomPizzie/7a5ff55ffa9081f2de27c315f5018afc">release history</a></li></ul></li><li>0.1<ul><li>Initial Release</li></ul></li></ul><h2 id="Authors"><a href="#Authors" class="headerlink" title="Authors"></a>Authors</h2><p>Contributors names and contact info</p><p>ex. Dominique Pizzie ex. <a href="https://twitter.com/dompizzie">@DomPizzie</a></p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>This project is licensed under the [NAME HERE] License - see the LICENSE.md file for details</p><h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><p>Inspiration, code snippets, etc.</p><ul><li><a href="https://github.com/matiassingers/awesome-readme">awesome-readme</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google检索技巧</title>
    <link href="/2020/12/29/toolkit/GoogleSearch/"/>
    <url>/2020/12/29/toolkit/GoogleSearch/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果你的信息来自朋友圈、微博、知乎、百度或是今日头条，那么你完蛋了。因为这些渠道有价值的信息不多，有营养的可能只有 1%，而为了这 1%，你需要读完 99% 的信息，太不划算了。</p><p>那么如何找到这些信息源呢？用好 Google 就是一个关键，比如你在 Google 搜索引擎里输入“XXX Best Practice”，或是“Best programming resource”……你就会找到很多。而用好这个更好的信息源需要你的英文能力，因此不断提升英文能力很关键。</p><p>下面将分享一些 Google 的常见检索技巧。</p><h2 id="基本搜索技巧"><a href="#基本搜索技巧" class="headerlink" title="基本搜索技巧"></a>基本搜索技巧</h2><p>1、+（英文）：逻辑”<strong>与</strong>“的意思，也可以用”<strong>空格</strong>“表示</p><p>搜索  Java  Go  </p><p>2、 -（英文）：逻辑”<strong>非</strong>“的意思</p><p>减号代表搜索<strong>不包含</strong>减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。减号更准确</p><p>搜索 美女 -帅哥 ，注意区别美女 - 帅哥和 美女-帅哥的搜索结果</p><p>3、| 逻辑”或”的意思 OR</p><p>4、完全匹配,双引号(“”)</p><p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。</p><p>5、* 星号</p><p>星号<em>是常用的通配符，也可以用在搜索中。百度不支持</em>号搜索指令。</p><p>搜索: 搜索*擎</p><p>6、~同义词</p><p>搜索 ~撩妹</p><h2 id="高级用法检索技巧"><a href="#高级用法检索技巧" class="headerlink" title="高级用法检索技巧"></a>高级用法检索技巧</h2><p>1、site<br>site这个高级搜索指令用来搜索某个域名下面的所有文件<br>搜索: 撩妹 site:zhihu.com</p><p>2、filetype</p><p>filetype搜索特定文件格式的时候使用,filetype用于搜索特定文件格式</p><p>搜索: filetype:pdf think java</p><p>3、intitle</p><p>intitle返回的是页面title中包含关键词的页面指令返回的是页面title中包含关键词的页面</p><p>搜索  intitle:rust</p><h2 id="如何利用检索解决问题"><a href="#如何利用检索解决问题" class="headerlink" title="如何利用检索解决问题"></a>如何利用检索解决问题</h2><ul><li>step 1： <strong>准备关键字</strong><ol><li>想象一下问题如果描叙</li><li>越详细越好</li><li>体现共性,而非特性</li></ol></li><li>step 2 ： <strong>仔细阅读结果,寻找关联性</strong><ol><li>没有结果-&gt;更换关键字</li><li>有蛛丝马迹-&gt;调整关键词,转换搜索方向</li></ol></li><li>step 3：<strong>重复上面过程,直到问题解决</strong></li></ul><h2 id="对于新事物可以搜索前辈的Top-tips-或者-Best-Practices"><a href="#对于新事物可以搜索前辈的Top-tips-或者-Best-Practices" class="headerlink" title="对于新事物可以搜索前辈的Top tips 或者 Best Practices"></a>对于新事物可以搜索前辈的Top tips 或者 Best Practices</h2><ul><li>XXX Top tips</li><li>XXX Best Practices</li><li>Best programming resource</li></ul><h2 id="对比性检索"><a href="#对比性检索" class="headerlink" title="对比性检索"></a>对比性检索</h2><ul><li>例如：检索 mysql中schema与database的区别<figure class="highlight pgsql"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">Difference <span class="hljs-keyword">Between</span> <span class="hljs-keyword">Schema</span> / <span class="hljs-keyword">Database</span> <span class="hljs-keyword">in</span> MySQL<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github检索技巧</title>
    <link href="/2020/12/26/toolkit/GitSearch/"/>
    <url>/2020/12/26/toolkit/GitSearch/</url>
    
    <content type="html"><![CDATA[<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><p><strong>1. 明确搜索仓库标题、仓库描述、README</strong></p><ul><li>仓库标题 <strong>in:name</strong> 关键词</li><li>仓库描叙 in:descripton 关键词</li><li>README <strong>in:readme</strong> 关键词</li></ul><p><strong>2. 明确搜索 star、fork 数大于多少的</strong></p><ul><li>stars: <strong>&gt;</strong> 数字 关键字。 stars:&gt;3000 spring cloud</li><li>fork : &gt; 数字 关键字</li></ul><p><strong>3. 明确搜索仓库大小的</strong></p><ul><li>size:&gt;=5000 关键词。 数字代表K, 5000代表着5M。</li></ul><p><strong>4. 明确仓库是否还在更新维护</strong></p><ul><li>pushed:&gt;2019-01-03 spring cloud</li><li>想找指定时间之前或之后创建的仓库也是可以的，把 pushed 改成 <strong>created</strong> 就行。</li></ul><p><strong>5. 明确搜索仓库的 LICENSE</strong></p><ul><li>license:apache-2.0 spring cloud</li></ul><p><strong>6. 明确搜索仓库的语言</strong></p><ul><li>language:java 关键词</li></ul><p><strong>7.明确搜索某个人或组织的仓库</strong></p><ul><li>user:joshlong</li></ul><figure class="highlight sqf"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf"><span class="hljs-comment">//常见组合</span><br><span class="hljs-built_in">in</span>:<span class="hljs-built_in">name</span> sso stars:&gt;<span class="hljs-number">1000</span> <span class="hljs-built_in">language</span>:java<br><br><span class="hljs-comment">//检索分布式锁</span><br><span class="hljs-built_in">in</span>:description 分布式锁 <span class="hljs-built_in">language</span>:java<br></code></pre></div></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://docs.github.com/en/free-pro-team@latest/github/searching-for-information-on-github/searching-for-repositories">GItHub helper</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编发编程｜六】Linux内核之kfifo</title>
    <link href="/2020/09/20/java/concurrent/linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bkfifo/"/>
    <url>/2020/09/20/java/concurrent/linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bkfifo/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.cnblogs.com/wangshaowei/p/11559522.html">https://www.cnblogs.com/wangshaowei/p/11559522.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【并发编程｜五】神奇的高性能无锁队列JCTools</title>
    <link href="/2020/09/20/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97JCTools/"/>
    <url>/2020/09/20/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97JCTools/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看Netty源码的时候，关注到了JCTools。JCTools是什么？是一个高性能的无锁并发工具包。早在96年就有论文提出了无锁队列的概念，再到后来 Disruptor，高性能已得到生产的验证。此处介绍的 Jctools 中的高性能队列，其性能丝毫不输于 Disruptor。那Disruptor与JCTools都是高性能队列的处理有什么区别了？</p><h2 id="什么是JCTools"><a href="#什么是JCTools" class="headerlink" title="什么是JCTools"></a>什么是JCTools</h2><p>JCTools (Java Concurrency Tools) 提供了一系列非阻塞并发数据结构（标准 Java 中缺失的），当存在线程争抢的时候，非阻塞并发数据结构比阻塞并发数据结构能提供更好的性能。</p><p>CTools 是适用于 JVM 并发开发的工具，主要提供了一些 JDK 确实的并发数据结构，例如非阻塞 Map、非阻塞 Queue 等。其中非阻塞队列可以分为四种类型，可以根据不同的场景选择使用。</p><p>JCTools 是一个开源工具包，在 Apache License 2.0 下发布，并在 Netty、Rxjava 等诸多框架中被广泛使用。</p><h3 id="非阻塞-Map"><a href="#非阻塞-Map" class="headerlink" title="非阻塞 Map"></a>非阻塞 Map</h3><ul><li>ConcurrentAutoTable<ul><li>后面几个map/set结构的基础</li></ul></li><li>NonBlockingHashMap :<ul><li>是对 ConcurrentHashMap 的增强，对多 CPU 的支持以及高并发更新提供更好的性能。</li></ul></li><li>NonBlockingHashMapLong <ul><li>是 key 为 Long 型的 NonBlockingHashMap。</li></ul></li><li>NonBlockingHashSet<ul><li>是对 NonBlockingHashMap 的简单包装以支持 set 的接口。</li></ul></li><li>NonBlockingIdentityHashMap <ul><li>是从 NonBlockingHashMap 改造来的，使用 System.identityHashCode() 来计算哈希。</li></ul></li><li>NonBlockingSetInt <ul><li>是一个使用 CAS 的简单的 bit-vector。</li></ul></li></ul><h3 id="非阻塞-Queue"><a href="#非阻塞-Queue" class="headerlink" title="非阻塞 Queue"></a>非阻塞 Queue</h3><p>JCTools 提供的非阻塞队列分为 四种类型，可以根据不同的应用场景选择使用：</p><ul><li>Spsc：单生产者单消费者（有界和无界）</li><li>Mpsc：多生产者单消费者（有界和无界）</li><li>Spmc：单生产者多消费者（有界）</li><li>Mpmc：多生产者多消费者（有界）</li></ul><p>“生产者”和“消费者”是指“生产线程”和“消费线程”。</p><h3 id="基于实现数据结构分类"><a href="#基于实现数据结构分类" class="headerlink" title="基于实现数据结构分类"></a>基于实现数据结构分类</h3><ul><li>基于数组的队列：<ul><li> MpscArrayQueue</li><li>MpmcArrayQueue</li><li>SpscArrayQueue</li><li>SpmcArrayQueue</li></ul></li><li>基于链表的队列： <ul><li>MpscLinkedQueue</li><li>SpscLinkedQueue</li></ul></li><li>基于<strong>LinkedArray</strong>的队列<ul><li>SpscChunkedArrayQueue</li><li>SpscGrowableArrayQueue</li><li>SpscUnboundedArrayQueue</li><li>MpscGrowableArrayQueue</li><li>MpscChunkedArrayQueue</li><li><strong>MpscUnboundedArrayQueue（Netty中使用）</strong></li></ul></li><li>XaddQueue：<ul><li>MpscUnboundedXaddArrayQueue</li><li>MpmcUnboundedXaddArrayQueue</li></ul></li><li>其它类型队列：<ul><li>MpscCompoundQueue</li></ul></li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>首先我们先从简单的 MpscArrayQueue 队列的源码开始分析：</p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/MpscArrayQueue.png"  width = "100%" height = "550"/><h4 id="入队offer"><a href="#入队offer" class="headerlink" title="入队offer()"></a>入队offer()</h4><p>跟进源码之前，首先回顾下 MpscArrayQueue 的重要属性</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ConcurrentCircularArrayQueue</span><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Q：这个值有什么作用？</span><br><span class="hljs-comment">    * A：数组长度对应的掩码 - 方便用&amp;运算代替较慢的%运算 子类需要继续缓存行填充，以避免mask 和 buffer 产生伪共享</span><br><span class="hljs-comment">    * eg.        capacity=16     0000 0000 0001 0000</span><br><span class="hljs-comment">    *      mask: capacity-1=15   0000 0000 0000 1111</span><br><span class="hljs-comment">    *  h &amp; (length-1) = h % length</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> mask; <br><br><span class="hljs-comment">// 真正存放队列数据的数组</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> E[] buffer; <br><br><br><span class="hljs-comment">// MpmcArrayQueueProducerIndexField</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> producerIndex; <span class="hljs-comment">// 生产者的索引</span><br><br><span class="hljs-comment">// MpscArrayQueueProducerLimitField</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在重新读取消费者索引之前，第一个不可用的生产者索引。</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Q: 这个值有什么用，直接读取consumerIndex计算不行吗?</span><br><span class="hljs-comment">     * A: &#123;<span class="hljs-doctag">@code</span> consumerIndex&#125;是一个变化较为频繁的值，因此它所在的缓存行极易失效，从而影响读性能。</span><br><span class="hljs-comment">     * 我们拷贝一个副本（并在副本无效的时候更新），这样可以减少生产者与消费者之间产生的伪共享，从而提高读效率.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Q: 该值为什么进行缓存行填充，为什么与producerIndex分离？</span><br><span class="hljs-comment">     * A: 因为是多生产模式，因此producerIndex上将产生高度竞争，因此其所在的缓存行极易失效，</span><br><span class="hljs-comment">     * 将该值与producerIndex分开，我们期望该值大部分时间位于用于共享（且很少失效）的缓存行中。</span><br><span class="hljs-comment">     * PS: 该值的更新频率远低于producerIndex。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> producerLimit; <br><br><span class="hljs-comment">// MpscArrayQueueConsumerIndexField</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消费者索引(当前消费进度).</span><br><span class="hljs-comment">     * 这是一个滞后值，消费者先消费可用槽位数据，再更新消费进度;</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> consumerIndex; <br></code></pre></div></td></tr></table></figure><p>跟进 offer() 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> E e)</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == e)<br>       &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>       &#125;<br><br>      <span class="hljs-comment">//producerLimit基于consumerIndex计算的一个缓存值，用户减少对consumerIndex的读取（减少缓存行miss），在循环中可能更新</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> mask = <span class="hljs-keyword">this</span>.mask;<br>       <span class="hljs-keyword">long</span> producerLimit = lvProducerLimit();<br>       <span class="hljs-keyword">long</span> pIndex;<br>       <span class="hljs-keyword">do</span><br>       &#123;<br>          <span class="hljs-comment">//获取生产者索引</span><br>           pIndex = lvProducerIndex();<br>           <span class="hljs-keyword">if</span> (pIndex &gt;= producerLimit)<br>           &#123;<br>               <span class="hljs-comment">// 生产者索引大于等于缓存的上限，表示根据缓存值认为队列已满。</span><br>               <span class="hljs-comment">// 此时，分两种情况：1. 队列真的满了。 2.缓存过期了。</span><br>               <span class="hljs-comment">// 因此需要读取最新的消费者索引，计算新的上限，判断队列是否是真的满了（以满足Queue对offer的语义要求）</span><br>               <br>               <span class="hljs-comment">// 获取消费者索引</span><br>               <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> cIndex = lvConsumerIndex();<br>               <span class="hljs-comment">//设计的很巧妙，仔细分析下。就是生产速度最大快于消费者一个容量的大小</span><br>               <span class="hljs-comment">//buffer 的大小=mask+1</span><br>               producerLimit = cIndex + mask + <span class="hljs-number">1</span>;<br>               <br>               <span class="hljs-comment">//生产速度是否快于消费速度</span><br>               <span class="hljs-keyword">if</span> (pIndex &gt;= producerLimit)<br>               &#123;<br>                   <span class="hljs-comment">// 最新的消费者索引显式队列确实已满</span><br>                   <span class="hljs-comment">// 只有当producerLimit大于producerIndex时更新才有意义，因此不更新producerLimit。</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// FULL :(</span><br>               &#125;<br>               <span class="hljs-keyword">else</span><br>               &#123;<br>                   <span class="hljs-comment">// 更新producerLimit为下一个我们必须重新检查消费者索引的值</span><br>                   <span class="hljs-comment">// 因为是多生产者模式，因此更新缓存会产生竞争。</span><br>                   <span class="hljs-comment">// Q: 为什么竞争是良性的？</span><br>                   <span class="hljs-comment">// A: 因为producerLimit永远不会超过下一次的计算值，而producerLimit小于实际值并不会带来错误。</span><br><br>                   <span class="hljs-comment">// update producer limit to the next index that we must recheck the consumer index</span><br>                   <span class="hljs-comment">// this is racy, but the race is benign</span><br>                   soProducerLimit(producerLimit);<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (!casProducerIndex(pIndex, pIndex + <span class="hljs-number">1</span>));<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * <span class="hljs-doctag">NOTE:</span> the new producer index value is made visible BEFORE the element in the array. If we relied on</span><br><span class="hljs-comment">        * the index visibility to poll() we would need to handle the case where the element is not visible.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-comment">// CAS 竞争成功，可以进行填充</span><br>       <span class="hljs-comment">// 提示：新的生产者索引值先于数组中的元素对其它线程可见。如果依赖于索引的可见性执行poll，我们将需要处理元素可能不可见的情况。</span><br><br>       <span class="hljs-comment">// 前面的CAS已经保证了对象的正确构造（安全发布），这里使用Ordered模式是保证尽快的可见性（volatile是立即的可见性）。</span><br>       <span class="hljs-comment">// 计算生产者索引在数组中下标</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> offset = calcCircularRefElementOffset(pIndex, mask);<br>       <span class="hljs-comment">// 向数组中放入数据</span><br>       soRefElement(buffer, offset, e);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br>   &#125;<br></code></pre></div></td></tr></table></figure><p>在初始化状态，producerLimit 与队列的容量是相等的，producerLimit = capacity = 4，而 producerIndex = consumerIndex = 0。接下来 Thread1 和 Thread2 并发向 MpscArrayQueue 中存放数据，如下图所示。</p><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/Mpsc-2.png" alt="image-20210826200206920"></p><p>两个线程此时拿到的 producerIndex 都是 0，是小于 producerLimit 的。此时两个线程都会尝试使用 CAS 操作更新 producerIndex，其中必然有一个是成功的，另外一个是失败的。</p><ol><li>假设 Thread-1 执行 CAS 操作成功，那么 Thread-2 失败后就会重新更新 producerIndex。</li><li>Thread-1 更新后 producerIndex 的值为 1，由于 producerIndex 是 volatile 修饰的，更新后立刻对 Thread-2 可见。</li><li>这里有一点需要注意的是，当前线程更新后的值是被其他线程使用，当 Thread-1 和 Thread-2 都通过 CAS 抢占成功后，它们拿到的 pIndex 分别是 0 和 1。接下来就是根据 pIndex 进行位运算计算得到数组对应的下标，然后通过 UNSAFE.putOrderedObject() 方法将数据写入到数组中，源码如下所示。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">soRefElement</span><span class="hljs-params">(E[] buffer, <span class="hljs-keyword">long</span> offset, E e)</span></span>&#123;<br>    UNSAFE.putOrderedObject(buffer, offset, e);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>putOrderedObject() 使用了 StoreStore Barrier，对于 Store1，StoreStore，Store2 这样的操作序列，在 Store2 进行写入之前，会保证 Store1 的写操作对其他处理器可见。保证写入都是最新的。</p><p>跟进源码 calcCircularRefElementOffset()</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算环形数组的指定（逻辑）索引对应的偏移量 - index为逻辑索引，需要转换为真实索引。</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 环形数组(环形缓冲区)的空间是重复利用的，因此逻辑上的index需要转换为真正的index然后再计算。</span><br><span class="hljs-comment">     * 为了高效运算，假定了环形数组的长度都为2的整次幂，因此mask应该为数组长度减1，这样可以使用 &#x27;&amp;&#x27; 快速计算。</span><br><span class="hljs-comment">     * eg. 数组大小为16 index=17 mask=15 index &amp; mask =1 </span><br><span class="hljs-comment">     * REF_ARRAY_BASE 数组中第一个元素的偏移地址， REF_ELEMENT_SHIFT：数组中一个元素占用的大小</span><br><span class="hljs-comment">     * Note: circular arrays are assumed a power of 2 in length and the `mask` is (length - 1).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index desirable element index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mask (length - 1)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the offset in bytes within the circular array for a given index</span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">calcCircularRefElementOffset</span><span class="hljs-params">(<span class="hljs-keyword">long</span> index, <span class="hljs-keyword">long</span> mask)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> REF_ARRAY_BASE + ((index &amp; mask) &lt;&lt; REF_ELEMENT_SHIFT);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="出队Poll"><a href="#出队Poll" class="headerlink" title="出队Poll"></a>出队Poll</h4><p>跟进poll()方法。方法作用移除队列的首个元素并返回，如果队列为空则返回 NULL</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 直接返回消费者索引 consumerIndex</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> cIndex = lpConsumerIndex();<br>        <span class="hljs-comment">// 计算数组对应的偏移量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> offset = calcCircularRefElementOffset(cIndex, mask);<br><br>        <span class="hljs-comment">// 读取为本地变量，避免在接下来的volatile读之后重新读取</span><br>        <span class="hljs-comment">// Copy field to avoid re-reading after volatile load</span><br>        <span class="hljs-keyword">final</span> E[] buffer = <span class="hljs-keyword">this</span>.buffer;<br><br>        <span class="hljs-comment">// 注意：生产者先更新索引，再填充元素，因此这里必须处理时序问题</span><br>        <span class="hljs-comment">// 如果元素不为null，那么可以安全的消费，因为生产者索引一定可见，但是如果元素为null，那么则必须等待其不为null。</span><br>        <span class="hljs-comment">// Q: 校验element而不是生产者索引，有什么好处？</span><br>        <span class="hljs-comment">// A: 可以减少对生产者索引的读！如果元素可见，那么不必读取生产者索引，可以减少缓存行miss问题。</span><br><br>        <span class="hljs-comment">// If we can&#x27;t see the next available element we can&#x27;t poll</span><br>        E e = lvRefElement(buffer, offset);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == e)<br>        &#123;<br>            <span class="hljs-comment">// null == e 有以下可能：</span><br>            <span class="hljs-comment">// 1. 队列为空</span><br>            <span class="hljs-comment">// 2. 生产者已经CAS更新了生产者索引，但是尚未填充元素，或填充的元素尚不可见 - 此时需要等待生产者完成填充，因为队列的状态表示当前并不为空！</span><br><br>            <span class="hljs-comment">// 提示：如果生产者在CAS更新生产者索引之后填充元素之前被中断，在这种情况下，队列并不是真正的为空。其它生产者会在该元素之后继续填充队列。</span><br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * <span class="hljs-doctag">NOTE:</span> Queue may not actually be empty in the case of a producer (P1) being interrupted after</span><br><span class="hljs-comment">             * winning the CAS on offer but before storing the element in the queue. Other producers may go on</span><br><span class="hljs-comment">             * to fill up the queue after this element.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (cIndex != lvProducerIndex())<br>            &#123;<br>                <span class="hljs-comment">// 队列不为空，需要自旋等待直到元素可见 - 这也是比relaxedPool开销大的原因</span><br>                <span class="hljs-keyword">do</span><br>                &#123;<br>                    e = lvRefElement(buffer, offset);<br>                &#125;<br>                <span class="hljs-keyword">while</span> (e == <span class="hljs-keyword">null</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 消费者索引和生产者索引相同，证明队列确实为空</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 先消费元素，再更新消费者进度（因为生产者会先校验consumerIndex，因此可确保生产者不会覆盖数据）。</span><br>        <span class="hljs-comment">// 这里可以使用Plain模式赋值为null，因为生产者一定会在索引可见之后才填充元素，consumerIndex的发布可以保证这里也正确发布。</span><br>        spRefElement(buffer, offset, <span class="hljs-keyword">null</span>);<br>        soConsumerIndex(cIndex + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>因为只有一个消费者线程，所以整个 poll() 的过程没有 CAS 操作。poll() 方法核心思路：</p><ol><li>是获取消费者索引 consumerIndex</li><li>根据 consumerIndex 计算得出数组对应的偏移量</li><li>将数组对应位置的元素取出并返回<ol><li>队列为null，直接返回</li><li>队列不为空，自旋直到获取到元素</li></ol></li><li>将 consumerIndex 移动到环形数组下一个位置。</li></ol><p>获取消费者索引以及计算数组对应的偏移量的逻辑与 offer() 类似，在这里就不赘述了。下面直接看下如何取出数组中 offset 对应的元素，跟进 lvElement() 方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">E <span class="hljs-title">lvRefElement</span><span class="hljs-params">(E[] buffer, <span class="hljs-keyword">long</span> offset)</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> (E) UNSAFE.getObjectVolatile(buffer, offset);<br>   &#125;<br></code></pre></div></td></tr></table></figure><p>获取数组元素的时候同样使用了 UNSAFE 系列方法，getObjectVolatile() 方法则使用的是 LoadLoad Barrier，对于 Load1，LoadLoad，Load2 操作序列，在 Load2 以及后续读取操作之前，会保证 Load1 的读取操作执行完毕，所以 getObjectVolatile() 方法可以保证每次读取数据都可以从内存中拿到最新值。</p><p>与 offer() 相反，poll() 比较关注队列为空的情况。当调用 lvElement() 方法获取到的元素为 NULL 时，有两种可能的情况：</p><ol><li>如果消费者索引 consumerIndex 等于生产者 producerIndex，说明队列为空。</li><li>只要两者不相等，消费者需要等待生产者填充数据完毕。(在 offer()  中先更新索引，然后填充数据)</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对 MpscArrayQueue 的知识点做一个简单的总结。</p><ul><li>通过大量填充 long 类型变量解决伪共享问题。</li><li>环形数组的容量设置为 2 的次幂，可以通过位运算快速定位到数组对应下标。</li><li>入队 offer() 操作中 producerLimit 的巧妙设计，大幅度减少了主动获取消费者索引 consumerIndex 的次数，性能提升显著。</li><li>入队和出队操作中都大量使用了 UNSAFE 系列方法，针对生产者和消费者的场景不同，使用的 UNSAFE 方法也是不一样的。</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>相关测试实践已经上传github  <a href="https://github.com/fengmingli/awesome-java/tree/main/middleware/jctools">repo</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol start="2"><li><a href="https://github.com/JCTools/JCTools/wiki/Getting-Started-With-JCTools">Github wiki</a></li><li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></li><li><a href="http://ifeve.com/memory-barriers-or-fences/">内存屏障</a></li><li><a href="https://github.com/JCTools/JCTools.git">Github repo</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【并发编程｜四】神奇的高性能无锁队列Disruptor</title>
    <link href="/2020/08/26/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor/"/>
    <url>/2020/08/26/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor/</url>
    
    <content type="html"><![CDATA[<h3 id="Disruptor为什么那么快？"><a href="#Disruptor为什么那么快？" class="headerlink" title="Disruptor为什么那么快？"></a>Disruptor为什么那么快？</h3><ul><li>预分配 ringbuffer</li><li>无锁（CAS）以及减小锁竞争</li><li>缓存行填充，消除伪共享</li><li>位运算的使用</li></ul><h3 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者/消费者模型"></a>生产者/消费者模型</h3><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/disruptor.png" alt="Disruptor"></p><h3 id="核心类关系"><a href="#核心类关系" class="headerlink" title="核心类关系"></a>核心类关系</h3><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/disruptorClassDiagram.png" alt="Disruptor Class Diagram"></p><p>由上图可以看出，所有的操作都是对 <strong>RingBuffer</strong> 进行的操作。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li><strong>Ring Buffer（环形缓冲区）:</strong><br>环形缓冲区通常被认为是Disruptor的主要方面，但从3.0开始，环形缓冲区仅负责存储和更新通过Disruptor的数据（事件）。对于一些高级用例，可以完全由用户替换。</li><li><strong>Sequence:</strong><br>Disruptor使用Sequences作为识别特定组件所在位置的方法。每个消费者（EventProcessor）都像Disruptor本身一样维护一个Sequence。大多数并发代码依赖于这些Sequence值的移动，因此Sequence支持AtomicLong的许多当前功能。事实上，两者之间唯一真正的区别是序列包含额外的功能，以防止序列和其他值之间的错误共享。</li><li><strong>Sequencer:</strong><br>Sequencer是Disruptor的真正核心。该接口的两个实现（单生成器，多生产者）实现了所有并发算法，用于在生产者和消费者之间快速，正确地传递数据。</li><li><strong>Sequence Barrier:</strong><br>序列屏障由序列发生器产生，包含对序列发生器中主要发布的序列和任何依赖性消费者的序列的引用。它包含确定是否有任何可供消费者处理的事件的逻辑。</li><li><strong>Wait Strategy:</strong><br>等待策略确定消费者如何等待生产者将事件放入Disruptor。有关可选锁定的部分中提供了更多详细信息。</li><li><strong>Event:</strong><br>从生产者传递给消费者的数据单位。事件没有特定的代码表示，因为它完全由用户定义。</li><li><strong>EventProcessor:</strong><br>用于处理来自Disruptor的事件的主事件循环，并具有消费者序列的所有权。有一个名为 BatchEventProcessor的表示，它包含事件循环的有效实现，并将回调到使用的提供的EventHandler接口实现。</li><li><strong>EventHandler:</strong><br>由用户实现并代表Disruptor的使用者的接口。</li><li><strong>Producer:</strong><br>这是调用Disruptor以将事件排入队列的用户代码。这个概念在代码中也没有表示。</li></ul><h3 id="生产者写入数据"><a href="#生产者写入数据" class="headerlink" title="生产者写入数据"></a>生产者写入数据</h3><ul><li><p><strong>写入数据的步骤包括：</strong></p><p>1.占位</p><p>2.移动游标并填充数据</p><p>3.发布事件</p></li><li><p><strong>需要考虑的问题：</strong></p><p><strong>1.如何避免生产者的生产速度过快而造成的新消息覆盖了未被消费的旧消息的问题</strong></p><p>答：生产者再获取占位之前需要查看当前最慢的消费者位置，如果当前要发布的位置比消费者大，就等待;</p><p><strong>2.如何解决多个生产者抢占生产位的问题</strong></p><p>答：多个生产者通过CAS获取生产位；</p></li></ul><h3 id="消费者消费数据"><a href="#消费者消费数据" class="headerlink" title="消费者消费数据"></a>消费者消费数据</h3><p>1.一个消费者一个线程；</p><p>2.每个消费者都有一个游标表示已经消费到哪了（Sequence）；</p><p>3.消息者会等待(waitFor)新数据，直到生产者通知(signal)；</p><ul><li><p><strong>需要考虑的问题：</strong></p><p><strong>如何防止读取的时候，读到还未写的元素？</strong></p><p>答：WaitStrategy（等待策略）</p></li></ul><h3 id="走进源码"><a href="#走进源码" class="headerlink" title="走进源码"></a>走进源码</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>笔者做实践 Disruptor 的时候，对生产者做了一次封装。这里可以通过 add()方法熟悉 disruptor的写入过程。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisruptorQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> Disruptor&lt;ObjectEvent&lt;T&gt;&gt; disruptor;<br>    <span class="hljs-keyword">private</span> RingBuffer&lt;ObjectEvent&lt;T&gt;&gt; ringBuffer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DisruptorQueue</span><span class="hljs-params">(Disruptor&lt;ObjectEvent&lt;T&gt;&gt; disruptor)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.disruptor = disruptor;<br>        <span class="hljs-keyword">this</span>.ringBuffer = disruptor.getRingBuffer();<br>        <span class="hljs-keyword">this</span>.disruptor.start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-comment">//1.获取ringbuffer下一个可写的序列</span><br>            <span class="hljs-keyword">long</span> sequence = <span class="hljs-keyword">this</span>.ringBuffer.next();<br>            <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">//2.获取对象事件，并进行数据填充</span><br>                ObjectEvent&lt;T&gt; event = <span class="hljs-keyword">this</span>.ringBuffer.get(sequence);<br>                event.setObj(t);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-comment">//3.发布事件</span><br>                <span class="hljs-keyword">this</span>.ringBuffer.publish(sequence);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(List&lt;T&gt; ts)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ts != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (T t : ts) &#123;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">this</span>.add(t);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br> <span class="hljs-comment">//省略。。。</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>从笔者封装可以看出 Disruptor 写入主要干了三件事：</p><ol><li>获取写一个可用的序列 sequence</li><li>通过 sequence 定位，ringBuffer 中的槽位。并填充槽位</li><li>发布事件</li></ol><p>基于上面三个步骤我们分别核心代码跟进</p><p>1.跟进代码：com.lmax.disruptor.SingleProducerSequencer#next(int)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;n must be &gt; 0&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">long</span> nextValue = <span class="hljs-keyword">this</span>.nextValue;<br>    <br>    <span class="hljs-comment">//在一个写入序列</span><br>    <span class="hljs-keyword">long</span> nextSequence = nextValue + n;<br>   <br>    <span class="hljs-comment">//后退一圈，仔细分析 wrapPoint就是consumer的最小消费位点。</span><br>    <span class="hljs-keyword">long</span> wrapPoint = nextSequence - bufferSize;<br>    <br>    <span class="hljs-comment">// 获取上一次的最小消费位置</span><br>    <span class="hljs-keyword">long</span> cachedGatingSequence = <span class="hljs-keyword">this</span>.cachedValue;<br>    <br>    <span class="hljs-comment">//生产者速度快于消费者且超生产一个rangbuffer大小，则没有剩余空间</span><br>    <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue)<br>    &#123;<br>      <span class="hljs-comment">//StoreLoad 更新游标</span><br>        cursor.setVolatile(nextValue);  <span class="hljs-comment">// StoreLoad fence</span><br><br>        <span class="hljs-keyword">long</span> minSequence;<br>       <br>       <span class="hljs-comment">//重新计算所有消费者里面的最小值位置</span><br>        <span class="hljs-keyword">while</span> (wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue)))<br>        &#123;<br>            <span class="hljs-comment">//防止死循环，让出CPu 暂停1纳秒，继续下一次计算</span><br>            LockSupport.parkNanos(<span class="hljs-number">1L</span>); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Use waitStrategy to spin?</span><br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.cachedValue = minSequence;<br>    &#125;<br>    <span class="hljs-comment">//下一个序列</span><br>    <span class="hljs-keyword">this</span>.nextValue = nextSequence;<br><br>    <span class="hljs-keyword">return</span> nextSequence;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2.跟进代码：com.lmax.disruptor.RingBufferFields#elementAt</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> E <span class="hljs-title">elementAt</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//通过 UNSAFE 方法获取指定序列的元素</span><br>   <span class="hljs-keyword">return</span> (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>3.跟进代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-comment">//更新游标</span><br>       cursor.set(sequence);<br>       <span class="hljs-comment">//如果阻塞则唤醒</span><br>       waitStrategy.signalAllWhenBlocking();<br>   &#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/blocking.png" alt="唤醒阻塞的消费者"></p><p>由于有些策略是阻塞性的，必须需要手动唤醒才能进行消费。具体策略感兴趣的朋友可以去深扒，代码不是很难。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>从封装的 DisruptorQueue 代码中可以看出，构造方法中 this.disruptor.start(); 方法。就是开启消费者线程。</p><p>跟进 com.lmax.disruptor.dsl.Disruptor#start</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RingBuffer&lt;T&gt; <span class="hljs-title">start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    checkOnlyStartedOnce();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ConsumerInfo consumerInfo : consumerRepository)<br>    &#123;<br>      <span class="hljs-comment">// 开启消费线程，如果多个就开启多个线程消费</span><br>        consumerInfo.start(executor);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ringBuffer;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>继续跟进源代码到：com.lmax.disruptor.BatchEventProcessor#run</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (running.compareAndSet(IDLE, RUNNING))<br>    &#123;<br>        sequenceBarrier.clearAlert();<br><br>        notifyStart();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (running.get() == RUNNING)<br>            &#123;<br>              <span class="hljs-comment">//真正处理事件的地方</span><br>                processEvents();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">finally</span><br>        &#123;<br>            notifyShutdown();<br>            running.set(IDLE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// This is a little bit of guess work.  The running state could of changed to HALTED by</span><br>        <span class="hljs-comment">// this point.  However, Java does not have compareAndExchange which is the only way</span><br>        <span class="hljs-comment">// to get it exactly correct.</span><br>        <span class="hljs-keyword">if</span> (running.get() == RUNNING)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Thread is already running&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            earlyExit();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>核心代码：com.lmax.disruptor.BatchEventProcessor#processEvents</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processEvents</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>       T event = <span class="hljs-keyword">null</span>;<br>       <span class="hljs-keyword">long</span> nextSequence = sequence.get() + <span class="hljs-number">1L</span>;<br><br>       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)<br>       &#123;<br>           <span class="hljs-keyword">try</span><br>           &#123;<br>              <span class="hljs-comment">//获取可用的序列，不同的等待策略有不同的效果</span><br>               <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);<br>               <span class="hljs-keyword">if</span> (batchStartAware != <span class="hljs-keyword">null</span>)<br>               &#123;<br>                   batchStartAware.onBatchStart(availableSequence - nextSequence + <span class="hljs-number">1</span>);<br>               &#125;<br>               <span class="hljs-comment">//事件消费，直到ringbuffer队列为null</span><br>               <span class="hljs-keyword">while</span> (nextSequence &lt;= availableSequence)<br>               &#123;<br>                   event = dataProvider.get(nextSequence);<br>                 <span class="hljs-comment">//用户实现消费的入口</span><br>                   eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);<br>                   nextSequence++;<br>               &#125;<br><br>               sequence.set(availableSequence);<br>           &#125;<br>           <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> TimeoutException e)<br>           &#123;<br>               notifyTimeout(sequence.get());<br>           &#125;<br>           <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> AlertException ex)<br>           &#123;<br>               <span class="hljs-keyword">if</span> (running.get() != RUNNING)<br>               &#123;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable ex)<br>           &#123;<br>               exceptionHandler.handleEventException(ex, nextSequence, event);<br>               sequence.set(nextSequence);<br>               nextSequence++;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><p>到这里对于Disruptor的生产流程，与消费流程就分析完了。有没有醍醐灌顶的感觉。。。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>Log4j2</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>笔者相关实践代码已经上传github  <a href="https://github.com/fengmingli/awesome-java/tree/main/middleware/jctools">repo</a></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://lmax-exchange.github.io/disruptor/disruptor.html">官网</a></li><li><a href="https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results">官网wiki</a></li><li><a href="http://ifeve.com/dissecting-disruptor-whats-so-special/">并发编程网</a></li><li><a href="https://www.iteye.com/blog/brokendreams-2255720">disruptor-3.3.2源码解析汇总</a></li><li><a href="https://tech.meituan.com/2016/11/18/disruptor.html">美团技术团队</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【并发编程｜三】漫谈JDK原生并发队列</title>
    <link href="/2020/08/21/java/concurrent/%E5%9B%9E%E9%A1%BEJDK%E5%8E%9F%E7%94%9F%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
    <url>/2020/08/21/java/concurrent/%E5%9B%9E%E9%A1%BEJDK%E5%8E%9F%E7%94%9F%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="回顾JDK原生并发队列"><a href="#回顾JDK原生并发队列" class="headerlink" title="回顾JDK原生并发队列"></a>回顾JDK原生并发队列</h3><p>队列是一种 FIFO（先进先出）的数据结构，JDK 中定义了 java.util.Queue 的队列接口，与 List、Set 接口类似，java.util.Queue 也继承于 Collection 集合接口。此外，JDK 还提供了一种双端队列接口 java.util.Deque，我们最常用的 LinkedList 就是实现了 Deque 接口。下面我们简单聊一聊每个队列的特点，并给出一些对比和总结。</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>阻塞队列在队列为空或者队列满时，都会发生阻塞。阻塞队列自身是线程安全的，使用者无需关心线程安全问题，降低了多线程开发难度。阻塞队列主要分为以下几种：</p><ul><li><strong>ArrayBlockingQueue</strong>：最基础且开发中最常用的阻塞队列，底层采用数组实现的有界队列，初始化需要指定队列的容量。ArrayBlockingQueue 是如何保证线程安全的呢？它内部是使用了一个重入锁 ReentrantLock，并搭配 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。从队列读取数据时，如果队列为空，那么会阻塞等待，直到队列有数据了才会被唤醒。如果队列已经满了，也同样会进入阻塞状态，直到队列有空闲才会被唤醒。</li><li><strong>LinkedBlockingQueue</strong>：内部采用的数据结构是链表，队列的长度可以是有界或者无界的，初始化不需要指定队列长度，默认是 Integer.MAX_VALUE。LinkedBlockingQueue 内部使用了 takeLock、putLock两个重入锁 ReentrantLock，以及 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。采用读锁和写锁的好处是可以避免读写时相互竞争锁的现象，所以相比于 ArrayBlockingQueue，LinkedBlockingQueue 的性能要更好。</li><li><strong>PriorityBlockingQueue</strong>：采用最小堆实现的优先级队列，队列中的元素按照优先级进行排列，每次出队都是返回优先级最高的元素。PriorityBlockingQueue 内部是使用了一个 ReentrantLock 以及一个条件变量 Condition notEmpty 来控制并发访问，不需要 notFull 是因为 PriorityBlockingQueue 是无界队列，所以每次 put 都不会发生阻塞。PriorityBlockingQueue 底层的最小堆是采用数组实现的，当元素个数大于等于最大容量时会触发扩容，在扩容时会先释放锁，保证其他元素可以正常出队，然后使用 CAS 操作确保只有一个线程可以执行扩容逻辑。</li><li><strong>DelayQueue</strong>，一种支持延迟获取元素的阻塞队列，常用于缓存、定时任务调度等场景。DelayQueue 内部是采用优先级队列 PriorityQueue 存储对象。DelayQueue 中的每个对象都必须实现 Delayed 接口，并重写 compareTo 和 getDelay 方法。向队列中存放元素的时候必须指定延迟时间，只有延迟时间已满的元素才能从队列中取出。</li><li><strong>SynchronizedQueue</strong>，又称无缓冲队列。比较特别的是 SynchronizedQueue 内部不会存储元素。与 ArrayBlockingQueue、LinkedBlockingQueue 不同，SynchronizedQueue 直接使用 CAS 操作控制线程的安全访问。其中 put 和 take 操作都是阻塞的，每一个 put 操作都必须阻塞等待一个 take 操作，反之亦然。所以 SynchronizedQueue 可以理解为生产者和消费者配对的场景，双方必须互相等待，直至配对成功。在 JDK 的线程池 Executors.newCachedThreadPool 中就存在 SynchronousQueue 的运用，对于新提交的任务，如果有空闲线程，将重复利用空闲线程处理任务，否则将新建线程进行处理。</li><li><strong>LinkedTransferQueue</strong>，一种特殊的无界阻塞队列，可以看作 LinkedBlockingQueues、SynchronousQueue（公平模式）、ConcurrentLinkedQueue 的合体。与 SynchronousQueue 不同的是，LinkedTransferQueue 内部可以存储实际的数据，当执行 put 操作时，如果有等待线程，那么直接将数据交给对方，否则放入队列中。与 LinkedBlockingQueues 相比，LinkedTransferQueue 使用 CAS 无锁操作进一步提升了性能。</li></ul><h4 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h4><p>聊完阻塞队列，我们再来看下非阻塞队列。非阻塞队列不需要通过加锁的方式对线程阻塞，并发性能更好。JDK 中常用的非阻塞队列有以下几种：</p><ul><li><strong>ConcurrentLinkedQueue</strong>，它是一个采用双向链表实现的无界并发非阻塞队列，它属于 LinkedQueue 的安全版本。ConcurrentLinkedQueue 内部采用 CAS 操作保证线程安全，这是非阻塞队列实现的基础，相比 ArrayBlockingQueue、LinkedBlockingQueue 具备较高的性能。</li><li><strong>ConcurrentLinkedDeque</strong>，也是一种采用双向链表结构的无界并发非阻塞队列。与 ConcurrentLinkedQueue 不同的是，ConcurrentLinkedDeque 属于双端队列，它同时支持 FIFO 和 FILO 两种模式，可以从队列的头部插入和删除数据，也可以从队列尾部插入和删除数据，适用于多生产者和多消费者的场景。</li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>在Java中用的最多队列的也就是BlockingQueue，所谓的Blocking就是入队或者出队时可能会产生阻塞，即没有元素或者容量已满。之所以是可能产生，是因为它支持多种操作,如add、offer等。基本所有的实现类都遵循这种规则。支持多个生产者和消费者，并且是线程安全的。</p><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/jdk-blockingQueue.png"></p><table><thead><tr><th>接口/行为</th><th>队列满抛出异常</th><th>返回元素</th><th>一直阻塞</th><th>阻塞一段时间</th></tr></thead><tbody><tr><td>新增</td><td>add</td><td>offer</td><td>put</td><td>offer</td></tr><tr><td>删除</td><td>remove</td><td>poll</td><td>take</td><td>poll</td></tr><tr><td>查询</td><td>element</td><td>peek</td><td>/</td><td>/</td></tr></tbody></table><p>JDK 提供的并发队列已经能够满足我们大部分的需求，但是在大规模流量的高并发系统中，如果你对性能要求严苛，JDK 的非阻塞并发队列可选择面较少且性能并不够出色。如果你还是需要一个数组 + CAS 操作实现的无锁安全队列，有没有成熟的解决方案呢？Java 强大的生态总能给我们带来惊喜，一些第三方框架提供的高性能无锁队列已经可以满足我们的需求，其中非常出名的有 Disruptor 和 JCTools。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【并发编程｜二】漫谈JVM内存屏障</title>
    <link href="/2020/08/20/java/concurrent/%E6%BC%AB%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2020/08/20/java/concurrent/%E6%BC%AB%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<p>作者最近很忙…</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【并发编程｜一】漫谈内存伪共享</title>
    <link href="/2020/08/20/java/concurrent/%E6%BC%AB%E8%B0%88%E5%86%85%E5%AD%98%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    <url>/2020/08/20/java/concurrent/%E6%BC%AB%E8%B0%88%E5%86%85%E5%AD%98%E4%BC%AA%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h2><p>在计算机组成中，CPU 的运算速度比内存高出几个数量级，为了 CPU 能够更高效地与内存进行交互，在 CPU 和内存之间设计了多层缓存机制，如下图所示。</p><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/cache.png" alt="image-20210827230748974"></p><p>一般来说，CPU 会分为三级缓存，分别为<strong>L1 一级缓存</strong>、<strong>L2 二级缓存</strong>和<strong>L3 三级缓存</strong>。越靠近 CPU 的缓存，速度越快，但是缓存的容量也越小。所以从性能上来说，L1 &gt; L2 &gt; L3，容量方面 L1 &lt; L2 &lt; L3。</p><p>CPU 读取数据时，首先会从 L1 查找，如果未命中则继续查找 L2，如果还未能命中则继续查找 L3，最后还没命中的话只能从内存中查找，读取完成后再将数据逐级放入缓存中。此外，多线程之间共享一份数据的时候，需要其中一个线程将数据写回主存，其他线程访问主存数据。</p><p>由此可见，引入多级缓存是为了能够让 CPU 利用率最大化。如果你在做频繁的 CPU 运算时，需要尽可能将数据保持在缓存中。</p><h4 id="什么是缓存行"><a href="#什么是缓存行" class="headerlink" title="什么是缓存行"></a>什么是缓存行</h4><p>Cache Line 是 CPU 缓存可操作的最小单位，CPU 缓存由若干个 Cache Line 组成。Cache Line 的大小与 CPU 架构有关，在目前主流的 64 位架构下，Cache Line 的大小通常为 64 Byte。Java 中一个 long 类型是 8 Byte，所以一个 Cache Line 可以存储 8 个 long 类型变量。CPU 在加载内存数据时，会将相邻的数据一同读取到 Cache Line 中，因为相邻的数据未来被访问的可能性最大，导致缓存好行失效，这样导致 CPU 频繁与内存进行交互。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">查看缓存行命令：<br>Mac：sysctl machdep.cpu.cache.linesize<br><br>Linux：getconf -a|grep CACHE  或者 cat /proc/cpuinfo |grep -I cache<br></code></pre></div></td></tr></table></figure><h4 id="伪共享如何产生的"><a href="#伪共享如何产生的" class="headerlink" title="伪共享如何产生的"></a>伪共享如何产生的</h4><ol><li>假设变量 x,y 被加载到同一个 Cache Line，它们会被高频地修改。</li><li>当线程 1 在 CPU Core1 中对变量 x 进行修改，修改完成后 CPU Core1 会通知其他 CPU Core 该缓存行已经失效。</li><li>然后线程 2 在 CPU Core2 中对变量 y 进行修改时，发现 Cache line 已经失效，此时 CPU Core1 会将数据重新写回内存，CPU Core2 再从内存中读取数据加载到当前 Cache line 中。</li></ol><h4 id="缓存一致性协议MESI"><a href="#缓存一致性协议MESI" class="headerlink" title="缓存一致性协议MESI"></a>缓存一致性协议<a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI</a></h4><p>每个处理器都有自己的高速缓存，而又共享同一主内存。<strong>当多个处理器都涉及同一块主内存区域的更改时，将导致各自的的缓存数据不一致</strong>。<strong>那同步到主内存时该以谁的缓存数据为准呢？</strong></p><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，来保证处理器间缓存的一致性。这类协议有MSI、<strong>MESI</strong>、MOSI等。</p><p>MESI是Modified（修改）、Exclusive（独占）、Shared（共享）、Invaild（失效）四种状态的缩写，是用来修饰<strong>缓存行</strong>的状态。在每个缓存行前额外使用2bit，来表示此四种状态。</p><ul><li>Modified（修改）：该缓存行仅出现在此cpu缓存中，缓存已被修改，和内存中不一致，等待同步至内存。</li><li>Exclusive（独占）：该缓存行仅出现在此cpu缓存中，缓存和内存中保持一致。</li><li>Shared（共享）：该缓存行可能出现在多个cpu缓存中，且多个cpu缓存的缓存行和内存中的数据一致。</li><li>Invalid（失效）：由于其他cpu修改了缓存行，导致本cpu中的缓存行失效。</li></ul><h4 id="如何规避伪共享"><a href="#如何规避伪共享" class="headerlink" title="如何规避伪共享"></a>如何规避伪共享</h4><p>目前为止最有效的办法就是，缓存行填充。空间换时间。</p><blockquote><p>Java8优雅解决：@sun.misc.Contended<br>注意：JVM启动参数加上-XX:-RestrictContended才会生效<br>最佳实践：ConcurrentHashMap.CounterCell</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【并发系列｜开篇】高性能无锁队列简介</title>
    <link href="/2020/07/23/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/07/23/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前做过一个反爬虫项目落地过程中使用到了Disruptor并感受到了Disruptor的神奇。最近看Netty源码过程中，同样发现了与Disruotor类似功能的无锁队列框架JCTools。能被Netty底层使用，可想JCTools也是非常牛逼。这里了笔者想写个系列文章记录下工作学习中的一些理解。</p><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/2020/08/20/java/concurrent/%E6%BC%AB%E8%B0%88%E5%86%85%E5%AD%98%E4%BC%AA%E5%85%B1%E4%BA%AB/" title="Java并发系列：漫谈内存伪共享">Java并发系列：漫谈内存伪共享</a></li><li><a href="/2020/08/20/java/concurrent/%E6%BC%AB%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" title="Java并发系列：漫谈JVM的内存屏障">Java并发系列：漫谈JVM的内存屏障</a></li><li><a href="/2020/08/21/java/concurrent/%E5%9B%9E%E9%A1%BEJDK%E5%8E%9F%E7%94%9F%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/" title="Java并发系列：漫谈JDK原生并发队列">Java并发系列：漫谈JDK原生并发队列</a></li><li><a href="/2020/08/26/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor/" title="Java并发系列：神奇的高性能无锁队列 Disruptor">Java并发系列：神奇的高性能无锁队列 Disruptor</a></li><li><a href="/2020/09/20/java/concurrent/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97JCTools/" title="Java并发系列：神奇的高性能无锁队列JCTools">Java并发系列：神奇的高性能无锁队列JCTools</a></li><li><a href="/2020/09/20/java/concurrent/linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bkfifo/" title="Linux内核之kfifo">Linux内核之kfifo</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神器的延迟任务处理之时间轮 HashedWheelTimer</title>
    <link href="/2020/06/19/middleware/netty/HashedWheelTimer/"/>
    <url>/2020/06/19/middleware/netty/HashedWheelTimer/</url>
    
    <content type="html"><![CDATA[<h3 id="时间轮原理分析"><a href="#时间轮原理分析" class="headerlink" title="时间轮原理分析"></a>时间轮原理分析</h3><p>技术有时就源于生活，例如排队买票可以想到队列，公司的组织关系可以理解为树等，而时间轮算法的设计思想就来源于钟表。如下图所示，时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。</p><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/wheeltime.png" alt="wheeltime"></p><p>任务是如何添加到时间轮当中的呢？可以根据任务的到期时间进行取模，然后将任务分布到不同的 slot 中。如上图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。假如现在需要调度一个 3s 后执行的任务，应该加入 2+3=5 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 零 4 个 slot，需要放入第 (2+12)%8=6 个 slot。</p><p>那么当时针走到第 6 个 slot 时，怎么区分每个任务是否需要立即执行，还是需要等待下一圈 round，甚至更久时间之后执行呢？所以我们需要把 round 信息保存在任务中。例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round=0，需要立即执行；第二个任务 round=1，需要等待 1<em>8=8s 后执行；第三个任务 round=2，需要等待 2</em>8=8s 后执行。所以当时针转动到对应 slot 时，只执行 round=0 的任务，slot 中其余任务的 round 应当减 1，等待下一个 round 之后执行。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="一切从构造函数开始"><a href="#一切从构造函数开始" class="headerlink" title="一切从构造函数开始"></a>一切从构造函数开始</h4><p>HashedWheelTimer 的构造函数清晰地列举出了几个核心属性：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashedWheelTimer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">long</span> tickDuration, TimeUnit unit, <span class="hljs-keyword">int</span> ticksPerWheel, <span class="hljs-keyword">boolean</span> leakDetection,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">long</span> maxPendingTimeouts)</span></span><br></code></pre></div></td></tr></table></figure><ul><li><strong>threadFactory</strong>，线程池，但是只创建了一个线程；</li><li><strong>tickDuration</strong>，时针每次 tick 的时间，相当于时针间隔多久走到下一个 slot；</li><li><strong>unit</strong>，表示 tickDuration 的时间单位；</li><li><strong>ticksPerWheel</strong>，时间轮上一共有多少个 slot，默认 512 个。分配的 slot 越多，占用的内存空间就越大；</li><li><strong>leakDetection</strong>，是否开启内存泄漏检测；</li><li><strong>maxPendingTimeouts</strong>，最大允许等待任务数。</li></ul><h4 id="创建时间轮"><a href="#创建时间轮" class="headerlink" title="创建时间轮"></a>创建时间轮</h4><p>时间轮的创建就是为了创建 HashedWheelBucket 数组，每个 HashedWheelBucket 表示时间轮中一个 slot。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashedWheelBucket[] createWheel(<span class="hljs-keyword">int</span> ticksPerWheel) &#123;<br>    <span class="hljs-comment">//ticksPerWheel may not be greater than 2^30</span><br>    checkInRange(ticksPerWheel, <span class="hljs-number">1</span>, <span class="hljs-number">1073741824</span>, <span class="hljs-string">&quot;ticksPerWheel&quot;</span>);<br><br>    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel); <br>    <span class="hljs-comment">//创建HashedWheelBucket 数组</span><br>    HashedWheelBucket[] wheel = <span class="hljs-keyword">new</span> HashedWheelBucket[ticksPerWheel];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wheel.length; i ++) &#123;<br>        wheel[i] = <span class="hljs-keyword">new</span> HashedWheelBucket();<br>    &#125;<br>    <span class="hljs-keyword">return</span> wheel;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>normalizeTicksPerWheel() 方法的作用就是找到不小于 ticksPerWheel 的最小 2 次幂，这个方法实现的并不好，可以参考 JDK HashMap 扩容 tableSizeFor 的实现进行性能优化，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">normalizeTicksPerWheel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ticksPerWheel)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> normalizedTicksPerWheel = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;<br>          normalizedTicksPerWheel &lt;&lt;= <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> normalizedTicksPerWheel;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>从 HashedWheelBucket 的结构定义可以看出，HashedWheelBucket 内部是一个双向链表结构，双向链表的每个节点持有一个 HashedWheelTimeout 对象，HashedWheelTimeout 代表一个定时任务。每个 HashedWheelBucket 都包含双向链表 head 和 tail 两个 HashedWheelTimeout 节点，这样就可以实现不同方向进行链表遍历。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashedWheelBucket</span> </span>&#123;<br>     <span class="hljs-comment">// Used for the linked-list datastructure</span><br>     <span class="hljs-keyword">private</span> HashedWheelTimeout head;<br>     <span class="hljs-keyword">private</span> HashedWheelTimeout tail;<br>     <span class="hljs-comment">//省略。。。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>HashedWheelTimer 初始化的主要工作主要就是创建一个HashedWheelBucket的数组，其内部结构与上文中介绍的时间轮算法类似，如下图所示：</p><p><img src="https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/wheeltime-2.png" alt="image-20210830115158721"></p><h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>HashedWheelTimer 初始化完成后，使用 HashedWheelTimer 提供的 newTimeout() 方法添加任务。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Timeout <span class="hljs-title">newTimeout</span><span class="hljs-params">(TimerTask task, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;<br>    checkNotNull(task, <span class="hljs-string">&quot;task&quot;</span>);<br>    checkNotNull(unit, <span class="hljs-string">&quot;unit&quot;</span>);<br><br>    <span class="hljs-keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();<br><br>    <span class="hljs-keyword">if</span> (maxPendingTimeouts &gt; <span class="hljs-number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;<br>        pendingTimeouts.decrementAndGet();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Number of pending timeouts (&quot;</span><br>            + pendingTimeoutsCount + <span class="hljs-string">&quot;) is greater than or equal to maximum allowed pending &quot;</span><br>            + <span class="hljs-string">&quot;timeouts (&quot;</span> + maxPendingTimeouts + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>  <br><span class="hljs-comment">//1.如果work线程没有启动则启动work线程</span><br>    start(); <br><br>    <span class="hljs-comment">//计算任务的deadline</span><br>    <span class="hljs-keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime; <br><br>    <span class="hljs-comment">// 防止溢出</span><br>    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span> &amp;&amp; deadline &lt; <span class="hljs-number">0</span>) &#123;<br>        deadline = Long.MAX_VALUE;<br>    &#125;<br>  <br>    <span class="hljs-comment">//2.创建定时任务 HashedWheelTimeout 对象</span><br>    HashedWheelTimeout timeout = <span class="hljs-keyword">new</span> HashedWheelTimeout(<span class="hljs-keyword">this</span>, task, deadline);<br>   <br>    <span class="hljs-comment">//3. 把定时任务 HashedWheelTimeout 添加到 Mpsc Queue </span><br>    timeouts.add(timeout);<br>    <span class="hljs-keyword">return</span> timeout;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>newTimeout() 方法主要做了三件事，分别为启动工作线程，创建定时任务，并把任务添加到 Mpsc Queue.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//工作线程的启动之前，会通过 CAS 操作获取工作线程的状态，如果已经启动，则直接跳过。</span><br>      <span class="hljs-comment">//如果没有启动，再次通过 CAS 操作更改工作线程状态，然后启动工作线程。</span><br>       <span class="hljs-keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="hljs-keyword">this</span>)) &#123;<br>           <span class="hljs-keyword">case</span> WORKER_STATE_INIT:<br>               <span class="hljs-keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;<br>                  <span class="hljs-comment">//直接调用的 Thread#start() 方法</span><br>                   workerThread.start();<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> WORKER_STATE_STARTED:<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> WORKER_STATE_SHUTDOWN:<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;cannot be started once stopped&quot;</span>);<br>           <span class="hljs-keyword">default</span>:<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Invalid WorkerState&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-comment">// Wait until the startTime is initialized by the worker.</span><br>       <span class="hljs-keyword">while</span> (startTime == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               startTimeInitialized.await();<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>               <span class="hljs-comment">// Ignore - it will be ready very soon.</span><br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><p>回到 newTimeout() 的主流程，接下来的逻辑就非常简单了。根据用户传入的任务延迟时间，可以计算出任务的 deadline，然后创建定时任务 HashedWheelTimeout 对象，最终把 HashedWheelTimeout 添加到 Mpsc Queue 中。</p><p>看到这里，你会不会有个疑问，为什么不是将 HashedWheelTimeout 直接添加到时间轮中呢？而是先添加到 Mpsc Queue？Mpsc Queue 可以理解为多生产者单消费者的线程安全队列。（<a href="">Java并发系列：神奇的高性能无锁队列JCTools</a>）。可以猜到 HashedWheelTimer 是想借助 Mpsc Queue 保证多线程向时间轮添加任务的线程安全性。</p><h4 id="工作线程-Worker"><a href="#工作线程-Worker" class="headerlink" title="工作线程 Worker"></a>工作线程 Worker</h4><p>工作线程 Worker 是时间轮的核心引擎，随着时针的转动，到期任务的处理都由 Worker 处理完成。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="hljs-keyword">new</span> HashSet&lt;Timeout&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> tick;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Initialize the startTime.</span><br>        startTime = System.nanoTime();<br>        <span class="hljs-keyword">if</span> (startTime == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 我们在这里使用 0 作为未初始化值的指示符，因此请确保在初始化时它不是 0。</span><br>            startTime = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Notify the other threads waiting for the initialization at start().</span><br>        startTimeInitialized.countDown();<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 1. 计算下次 tick 的时间, 然后sleep 到下次 tick</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = waitForNextTick();<br>            <span class="hljs-comment">// 可能因为溢出或者线程中断，造成 deadline &lt;= 0</span><br>            <span class="hljs-keyword">if</span> (deadline &gt; <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-comment">// 2. 获取当前 tick 在 HashedWheelBucket 数组中对应的下标</span><br>                <span class="hljs-keyword">int</span> idx = (<span class="hljs-keyword">int</span>) (tick &amp; mask);<br>               <span class="hljs-comment">// 3. 移除被取消的任务</span><br>                processCancelledTasks();<br>                HashedWheelBucket bucket = wheel[idx];<br>                <span class="hljs-comment">// 4. 从 Mpsc Queue 中取出任务加入对应的 slot 中</span><br>                transferTimeoutsToBuckets();<br>                <span class="hljs-comment">// 5. 执行到期的任务</span><br>                bucket.expireTimeouts(deadline);<br>                tick++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="hljs-keyword">this</span>) == WORKER_STATE_STARTED);<br><br>        <span class="hljs-comment">// 时间轮退出后，取出 slot 中未执行且未被取消的任务，并加入未处理任务列表，以便 stop() 方法返回</span><br>        <span class="hljs-keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;<br>            bucket.clearTimeouts(unprocessedTimeouts);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-comment">// 将还没来得及添加到 slot 中的任务取出，如果任务未取消则加入未处理任务列表，以便 stop() 方法返回</span><br>            HashedWheelTimeout timeout = timeouts.poll();<br>            <span class="hljs-keyword">if</span> (timeout == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!timeout.isCancelled()) &#123;<br>               <span class="hljs-comment">//加入未处理任务队列</span><br>                unprocessedTimeouts.add(timeout);<br>            &#125;<br>        &#125;<br>        processCancelledTasks();<br>    &#125;<br>  <span class="hljs-comment">//省略。。。</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>工作线程 Worker 的核心执行流程是代码中的 do-while 循环，只要 Worker 处于 STARTED 状态，就会执行 do-while 循环，我们把该过程拆分成为以下几个步骤。</p><ul><li>通过 waitForNextTick() 方法计算出时针到下一次 tick 的时间间隔，然后 sleep 到下一次 tick。</li><li>通过位运算获取当前 tick 在 HashedWheelBucket 数组中对应的下标</li><li>移除被取消的任务。</li><li>从 Mpsc Queue 中取出任务加入对应的 HashedWheelBucket 中。</li><li>执行当前 HashedWheelBucket 中的到期任务。</li></ul><h4 id="停止时间轮"><a href="#停止时间轮" class="headerlink" title="停止时间轮"></a>停止时间轮</h4><p>回到 Timer 接口两个方法，newTimeout() 上文已经分析完了，接下来我们就以 stop() 方法为入口，看下时间轮停止都做了哪些工作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Timeout&gt; <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-comment">// Worker 线程无法停止时间轮</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() == workerThread) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br>                HashedWheelTimer.class.getSimpleName() +<br>                        <span class="hljs-string">&quot;.stop() cannot be called from &quot;</span> +<br>                        TimerTask.class.getSimpleName());<br>    &#125;<br>    <span class="hljs-comment">// 尝试通过 CAS 操作将工作线程的状态更新为 SHUTDOWN 状态</span><br>    <span class="hljs-keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;<br>        <span class="hljs-comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span><br>        <span class="hljs-keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="hljs-keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;<br>            INSTANCE_COUNTER.decrementAndGet();<br>            <span class="hljs-keyword">if</span> (leak != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">boolean</span> closed = leak.close(<span class="hljs-keyword">this</span>);<br>                <span class="hljs-keyword">assert</span> closed;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Collections.emptySet();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span> (workerThread.isAlive()) &#123;<br>           <span class="hljs-comment">// 中断 Worker 线程</span><br>            workerThread.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                workerThread.join(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>                interrupted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (interrupted) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        INSTANCE_COUNTER.decrementAndGet();<br>        <span class="hljs-keyword">if</span> (leak != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">boolean</span> closed = leak.close(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">assert</span> closed;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回未处理任务的列表</span><br>    <span class="hljs-keyword">return</span> worker.unprocessedTimeouts();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>如果当前线程是 Worker 线程，它是不能发起停止时间轮的操作的，是为了防止有定时任务发起停止时间轮的恶意操作。停止时间轮主要做了三件事，首先尝试通过 CAS 操作将工作线程的状态更新为 SHUTDOWN 状态，然后中断工作线程 Worker，最后将未处理的任务列表返回给上层。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>回顾一下 HashedWheelTimer 的几个核心成员。</p><ul><li><strong>HashedWheelTimeout</strong>，任务的封装类，包含任务的到期时间 deadline、需要经历的圈数 remainingRounds 等属性。</li><li><strong>HashedWheelBucket</strong>，相当于时间轮的每个 slot，内部采用双向链表保存了当前需要执行的 HashedWheelTimeout 列表。</li><li><strong>Worker</strong>，HashedWheelTimer 的核心工作引擎，负责处理定时任务。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 Hexo + Github Actions 搭建个人博客</title>
    <link href="/2020/05/20/toolkit/Hexo/"/>
    <url>/2020/05/20/toolkit/Hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="https://nodejs.org/en/">Node.js</a>   (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></div></td></tr></table></figure><h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3>对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm install hexo<br></code></pre></div></td></tr></table></figure>安装以后，可以使用以下两种方式执行 Hexo：</li></ul><ol><li>npx hexo <command></li><li>将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo <command>：<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$  hexo new [layout] &lt;title&gt;<br></code></pre></div></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。<br><a href="https://hexo.io/docs/writing.html">更多信息</a></p><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><p>到这里，应该写完了一篇新的文章。赶紧通过 hexo 本地部署</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server  或者 hexo s<br></code></pre></div></td></tr></table></figure><p><a href="https://hexo.io/docs/server.html">更多信息</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate  或者 hexo g<br></code></pre></div></td></tr></table></figure><p><a href="https://hexo.io/docs/generating.html">更多信息</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><ul><li>首先需要在 GitHub 上面新建一个 repository。如果你希望你的站点能通过 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 域名访问，你的 repository 应该直接命名为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>。</li><li>将你的 Hexo 站点文件夹推送到 repository 中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#修改Hexo的_config.yml配置文件</span><br>deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: git@github.com:xxxx/xxxx.github.io.git<br>  branch: master<br>  message: <span class="hljs-string">&quot;提交的信息&quot;</span><br><br><span class="hljs-comment">#发布到github仓库</span><br>$ hexo deploy 或者 hexo d<br></code></pre></div></td></tr></table></figure><p> <a href="https://hexo.io/docs/one-command-deployment.html">更多信息</a></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Hexo 目前已经提供了很多漂亮的主题 ，找一个自己喜欢的即可。</p><ul><li><a href="https://hexo.io/themes/">主题链接</a></li><li><a href="https://hexo.fluid-dev.com/docs/">本站使用的主题</a></li></ul><h2 id="利用-Github-Actions-自动部署-Hexo-博客"><a href="#利用-Github-Actions-自动部署-Hexo-博客" class="headerlink" title="利用 Github Actions 自动部署 Hexo 博客"></a>利用 Github Actions 自动部署 Hexo 博客</h2><p>已经有大神整理了文档,我也是按照这文档完成部署的。这里我就不重复造轮子了 <a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">跳转链接</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://blog.jijian.link/2020-01-10/hexo-gitalk-auto-init/">gitalk 自动生成issue</a></p></li><li><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98">fluid主题</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
