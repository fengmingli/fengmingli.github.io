(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{346:function(e,t,u){"use strict";u.r(t);var n=u(1),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"回顾jdk原生并发队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回顾jdk原生并发队列"}},[e._v("#")]),e._v(" 回顾JDK原生并发队列")]),e._v(" "),t("p",[e._v("队列是一种 FIFO（先进先出）的数据结构，JDK 中定义了 java.util.Queue 的队列接口，与 List、Set 接口类似，java.util.Queue 也继承于 Collection 集合接口。此外，JDK 还提供了一种双端队列接口 java.util.Deque，我们最常用的 LinkedList 就是实现了 Deque 接口。下面我们简单聊一聊每个队列的特点，并给出一些对比和总结。")]),e._v(" "),t("h4",{attrs:{id:"阻塞队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[e._v("#")]),e._v(" 阻塞队列")]),e._v(" "),t("p",[e._v("阻塞队列在队列为空或者队列满时，都会发生阻塞。阻塞队列自身是线程安全的，使用者无需关心线程安全问题，降低了多线程开发难度。阻塞队列主要分为以下几种：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("ArrayBlockingQueue")]),e._v("：最基础且开发中最常用的阻塞队列，底层采用数组实现的有界队列，初始化需要指定队列的容量。ArrayBlockingQueue 是如何保证线程安全的呢？它内部是使用了一个重入锁 ReentrantLock，并搭配 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。从队列读取数据时，如果队列为空，那么会阻塞等待，直到队列有数据了才会被唤醒。如果队列已经满了，也同样会进入阻塞状态，直到队列有空闲才会被唤醒。")]),e._v(" "),t("li",[t("strong",[e._v("LinkedBlockingQueue")]),e._v("：内部采用的数据结构是链表，队列的长度可以是有界或者无界的，初始化不需要指定队列长度，默认是 Integer.MAX_VALUE。LinkedBlockingQueue 内部使用了 takeLock、putLock两个重入锁 ReentrantLock，以及 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。采用读锁和写锁的好处是可以避免读写时相互竞争锁的现象，所以相比于 ArrayBlockingQueue，LinkedBlockingQueue 的性能要更好。")]),e._v(" "),t("li",[t("strong",[e._v("PriorityBlockingQueue")]),e._v("：采用最小堆实现的优先级队列，队列中的元素按照优先级进行排列，每次出队都是返回优先级最高的元素。PriorityBlockingQueue 内部是使用了一个 ReentrantLock 以及一个条件变量 Condition notEmpty 来控制并发访问，不需要 notFull 是因为 PriorityBlockingQueue 是无界队列，所以每次 put 都不会发生阻塞。PriorityBlockingQueue 底层的最小堆是采用数组实现的，当元素个数大于等于最大容量时会触发扩容，在扩容时会先释放锁，保证其他元素可以正常出队，然后使用 CAS 操作确保只有一个线程可以执行扩容逻辑。")]),e._v(" "),t("li",[t("strong",[e._v("DelayQueue")]),e._v("，一种支持延迟获取元素的阻塞队列，常用于缓存、定时任务调度等场景。DelayQueue 内部是采用优先级队列 PriorityQueue 存储对象。DelayQueue 中的每个对象都必须实现 Delayed 接口，并重写 compareTo 和 getDelay 方法。向队列中存放元素的时候必须指定延迟时间，只有延迟时间已满的元素才能从队列中取出。")]),e._v(" "),t("li",[t("strong",[e._v("SynchronizedQueue")]),e._v("，又称无缓冲队列。比较特别的是 SynchronizedQueue 内部不会存储元素。与 ArrayBlockingQueue、LinkedBlockingQueue 不同，SynchronizedQueue 直接使用 CAS 操作控制线程的安全访问。其中 put 和 take 操作都是阻塞的，每一个 put 操作都必须阻塞等待一个 take 操作，反之亦然。所以 SynchronizedQueue 可以理解为生产者和消费者配对的场景，双方必须互相等待，直至配对成功。在 JDK 的线程池 Executors.newCachedThreadPool 中就存在 SynchronousQueue 的运用，对于新提交的任务，如果有空闲线程，将重复利用空闲线程处理任务，否则将新建线程进行处理。")]),e._v(" "),t("li",[t("strong",[e._v("LinkedTransferQueue")]),e._v("，一种特殊的无界阻塞队列，可以看作 LinkedBlockingQueues、SynchronousQueue（公平模式）、ConcurrentLinkedQueue 的合体。与 SynchronousQueue 不同的是，LinkedTransferQueue 内部可以存储实际的数据，当执行 put 操作时，如果有等待线程，那么直接将数据交给对方，否则放入队列中。与 LinkedBlockingQueues 相比，LinkedTransferQueue 使用 CAS 无锁操作进一步提升了性能。")])]),e._v(" "),t("h4",{attrs:{id:"非阻塞队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞队列"}},[e._v("#")]),e._v(" 非阻塞队列")]),e._v(" "),t("p",[e._v("聊完阻塞队列，我们再来看下非阻塞队列。非阻塞队列不需要通过加锁的方式对线程阻塞，并发性能更好。JDK 中常用的非阻塞队列有以下几种：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("ConcurrentLinkedQueue")]),e._v("，它是一个采用双向链表实现的无界并发非阻塞队列，它属于 LinkedQueue 的安全版本。ConcurrentLinkedQueue 内部采用 CAS 操作保证线程安全，这是非阻塞队列实现的基础，相比 ArrayBlockingQueue、LinkedBlockingQueue 具备较高的性能。")]),e._v(" "),t("li",[t("strong",[e._v("ConcurrentLinkedDeque")]),e._v("，也是一种采用双向链表结构的无界并发非阻塞队列。与 ConcurrentLinkedQueue 不同的是，ConcurrentLinkedDeque 属于双端队列，它同时支持 FIFO 和 FILO 两种模式，可以从队列的头部插入和删除数据，也可以从队列尾部插入和删除数据，适用于多生产者和多消费者的场景。")])]),e._v(" "),t("h4",{attrs:{id:"基本使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本使用"}},[e._v("#")]),e._v(" 基本使用")]),e._v(" "),t("p",[e._v("在Java中用的最多队列的也就是BlockingQueue，所谓的Blocking就是入队或者出队时可能会产生阻塞，即没有元素或者容量已满。之所以是可能产生，是因为它支持多种操作,如add、offer等。基本所有的实现类都遵循这种规则。支持多个生产者和消费者，并且是线程安全的。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://lfm-image-1258982381.cos.ap-shanghai.myqcloud.com/image/jdk-blockingQueue.png",alt:""}})]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("接口/行为")]),e._v(" "),t("th",[e._v("队列满抛出异常")]),e._v(" "),t("th",[e._v("返回元素")]),e._v(" "),t("th",[e._v("一直阻塞")]),e._v(" "),t("th",[e._v("阻塞一段时间")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("新增")]),e._v(" "),t("td",[e._v("add")]),e._v(" "),t("td",[e._v("offer")]),e._v(" "),t("td",[e._v("put")]),e._v(" "),t("td",[e._v("offer")])]),e._v(" "),t("tr",[t("td",[e._v("删除")]),e._v(" "),t("td",[e._v("remove")]),e._v(" "),t("td",[e._v("poll")]),e._v(" "),t("td",[e._v("take")]),e._v(" "),t("td",[e._v("poll")])]),e._v(" "),t("tr",[t("td",[e._v("查询")]),e._v(" "),t("td",[e._v("element")]),e._v(" "),t("td",[e._v("peek")]),e._v(" "),t("td",[e._v("/")]),e._v(" "),t("td",[e._v("/")])])])]),e._v(" "),t("p",[e._v("JDK 提供的并发队列已经能够满足我们大部分的需求，但是在大规模流量的高并发系统中，如果你对性能要求严苛，JDK 的非阻塞并发队列可选择面较少且性能并不够出色。如果你还是需要一个数组 + CAS 操作实现的无锁安全队列，有没有成熟的解决方案呢？Java 强大的生态总能给我们带来惊喜，一些第三方框架提供的高性能无锁队列已经可以满足我们的需求，其中非常出名的有 Disruptor 和 JCTools。")])])}),[],!1,null,null,null);t.default=r.exports}}]);