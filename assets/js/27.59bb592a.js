(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{356:function(e,o,i){"use strict";i.r(o);var r=i(1),t=Object(r.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"调度算法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[e._v("#")]),e._v(" 调度算法")]),e._v(" "),o("p",[e._v("kube-scheduler的根本工作任务是根据各种调度算法将Pod绑定（bind）到最合适的工作节点，整个调度流程分为两个阶段：预选策略（Predicates）和优选策略（Priorities）。")]),e._v(" "),o("ul",[o("li",[e._v("预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube-scheduler根据预选策略过滤掉不满足策略的Nodes。例如，如果某节点的资源不足或者不满足预选策略的条件如“Node的label必须与Pod的Selector一致”时则无法通过预选。")]),e._v(" "),o("li",[e._v("优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的Nodes进行打分排名，选择得分最高的Node。例如，资源越富裕、负载越小的Node可能具有越高的排名。")])]),e._v(" "),o("h3",{attrs:{id:"预选策略-predicates"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#预选策略-predicates"}},[e._v("#")]),e._v(" "),o("a",{attrs:{href:"https://github1s.com/kubernetes/kubernetes/blob/v1.14.4/pkg/scheduler/algorithm/predicates/predicates.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("预选策略（Predicates) "),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("过滤条件包含如下：")]),e._v(" "),o("ul",[o("li",[e._v("PodFitsHostPorts：检查Pod容器所需的HostPort是否已被节点上其它容器或服务占用。如果已被占用，则禁止Pod调度到该节点。")]),e._v(" "),o("li",[e._v("PodFitsHost：检查Pod指定的NodeName是否匹配当前节点。")]),e._v(" "),o("li",[e._v("PodFitsResources：检查节点是否有足够空闲资源（例如CPU和内存）来满足Pod的要求。")]),e._v(" "),o("li",[e._v("PodMatchNodeSelector：检查Pod的节点选择器(nodeSelector)是否与节点(Node)的标签匹配")]),e._v(" "),o("li",[e._v("NoVolumeZoneConflict：对于给定的某块区域，判断如果在此区域的节点上部署Pod是否存在卷冲突。")]),e._v(" "),o("li",[e._v("NoDiskConflict：根据节点请求的卷和已经挂载的卷，评估Pod是否适合该节点。")]),e._v(" "),o("li",[e._v("MaxCSIVolumeCount：决定应该附加多少CSI卷，以及该卷是否超过配置的限制。")]),e._v(" "),o("li",[e._v("CheckNodeMemoryPressure：如果节点报告内存压力，并且没有配置异常，那么将不会往那里调度Pod。")]),e._v(" "),o("li",[e._v("CheckNodePIDPressure：如果节点报告进程id稀缺，并且没有配置异常，那么将不会往那里调度Pod。")]),e._v(" "),o("li",[e._v("CheckNodeDiskPressure：如果节点报告存储压力(文件系统已满或接近满)，并且没有配置异常，那么将不会往那里调度Pod。")]),e._v(" "),o("li",[e._v("CheckNodeCondition：节点可以报告它们有一个完全完整的文件系统，然而网络不可用，或者kubelet没有准备好运行Pods。如果为节点设置了这样的条件，并且没有配置异常，那么将不会往那里调度Pod。")]),e._v(" "),o("li",[e._v("PodToleratesNodeTaints：检查Pod的容忍度是否能容忍节点的污点。")]),e._v(" "),o("li",[e._v("CheckVolumeBinding：评估Pod是否适合它所请求的容量。这适用于约束和非约束PVC。")])]),e._v(" "),o("p",[e._v("「注意」 如果在predicates(预选)过程中没有合适的节点，那么Pod会一直在pending状态，不断重试调度，直到有节点满足条件。")]),e._v(" "),o("p",[e._v("经过这个步骤，如果有多个节点满足条件，就继续priorities过程，最后按照优先级大小对节点排序。")]),e._v(" "),o("h3",{attrs:{id:"优选策略-priorities"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#优选策略-priorities"}},[e._v("#")]),e._v(" "),o("a",{attrs:{href:"https://github1s.com/kubernetes/kubernetes/blob/v1.14.4/pkg/scheduler/algorithm/predicates/predicates.go#L142",target:"_blank",rel:"noopener noreferrer"}},[e._v("优选策略（Priorities）"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("包含如下优选评分条件：")]),e._v(" "),o("ul",[o("li",[e._v("SelectorSpreadPriority：对于属于同一服务、有状态集或副本集（Service，StatefulSet or ReplicaSet）的Pods，会将Pods尽量分散到不同主机上。")]),e._v(" "),o("li",[e._v("InterPodAffinityPriority：策略有podAffinity和podAntiAffinity两种配置方式。简单来说，就说根据Node上运行的Pod的Label来进行调度匹配的规则，匹配的表达式有：In, NotIn, Exists, DoesNotExist，通过该策略，可以更灵活地对Pod进行调度。")]),e._v(" "),o("li",[e._v("LeastRequestedPriority：偏向使用较少请求资源的节点。换句话说，放置在节点上的Pod越多，这些Pod使用的资源越多，此策略给出的排名就越低。")]),e._v(" "),o("li",[e._v("MostRequestedPriority：偏向具有最多请求资源的节点。这个策略将把计划的Pods放到整个工作负载集所需的最小节点上运行。")]),e._v(" "),o("li",[e._v("RequestedToCapacityRatioPriority：使用默认的资源评分函数模型创建基于ResourceAllocationPriority的requestedToCapacity。")]),e._v(" "),o("li",[e._v("BalancedResourceAllocation：偏向具有平衡资源使用的节点。")]),e._v(" "),o("li",[e._v("NodePreferAvoidPodsPriority：根据节点注释scheduler.alpha.kubernet .io/preferAvoidPods为节点划分优先级。可以使用它来示意两个不同的Pod不应在同一Node上运行。")]),e._v(" "),o("li",[e._v("NodeAffinityPriority：根据preferredduringschedulingignoredingexecution中所示的节点关联调度偏好来对节点排序。")]),e._v(" "),o("li",[e._v("TaintTolerationPriority：根据节点上无法忍受的污点数量，为所有节点准备优先级列表。此策略将考虑该列表调整节点的排名。")]),e._v(" "),o("li",[e._v("ImageLocalityPriority：偏向已经拥有本地缓存Pod容器镜像的节点。")]),e._v(" "),o("li",[e._v("ServiceSpreadingPriority：对于给定的服务，此策略旨在确保Service的Pods运行在不同的节点上。总的结果是，Service对单个节点故障变得更有弹性。")]),e._v(" "),o("li",[e._v("EqualPriority：赋予所有节点相同的权值1。")]),e._v(" "),o("li",[e._v("EvenPodsSpreadPriority：实现择优 pod的拓扑扩展约束")])])])}),[],!1,null,null,null);o.default=t.exports}}]);